"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchMaker = void 0;
const DiffMatcher_1 = require("../matcher/DiffMatcher");
const ObjectMatcher_1 = require("../matcher/ObjectMatcher");
const ofType_1 = require("../ofType");
const IsEqualsMatcher_1 = require("../matcher/IsEqualsMatcher");
const ArrayMatcher_1 = require("../matcher/ArrayMatcher");
const RegExpMatcher_1 = require("../matcher/RegExpMatcher");
const StringMatcher_1 = require("../matcher/StringMatcher");
const NumberMatcher_1 = require("../matcher/NumberMatcher");
const ErrorMatcher_1 = require("../matcher/ErrorMatcher");
const PrettyPrinter_1 = require("../prettyPrint/PrettyPrinter");
const AnyMatcher_1 = require("../matcher/AnyMatcher");
const CustomiseMismatcher_1 = require("./CustomiseMismatcher");
const SetMatcher_1 = require("../matcher/SetMatcher");
const Mismatched_1 = require("../matcher/Mismatched");
const MatchResult_1 = require("../MatchResult");
let level = 0;
const references = new Set();
const selfReferences = new Map();
function matchMaker(expected) {
    const existingSelfRef = selfReferences.get(expected);
    if (existingSelfRef) {
        return existingSelfRef;
    }
    if (references.has(expected)) {
        const selfReferenceMatcher = SelfReferenceMatcher.make();
        selfReferences.set(expected, selfReferenceMatcher);
        return selfReferenceMatcher;
    }
    level += 1;
    try {
        if (ofType_1.ofType.isMatcher(expected)) {
            return expected;
        }
        if (ofType_1.ofType.isString(expected)) {
            return StringMatcher_1.StringMatcher.make(expected);
        }
        if (ofType_1.ofType.isNaN(expected)) { // Need to check before isNumber()
            return NumberMatcher_1.numberMatcher.nan();
        }
        if (ofType_1.ofType.isUndefined(expected) || ofType_1.ofType.isNull(expected) || ofType_1.ofType.isNumber(expected) ||
            ofType_1.ofType.isBoolean(expected) || ofType_1.ofType.isSymbol(expected)) {
            return IsEqualsMatcher_1.IsEqualsMatcher.make(expected);
        }
        if (ofType_1.ofType.isArray(expected)) {
            references.add(expected);
            try {
                const arrayMatcher = ArrayMatcher_1.ArrayMatcher.make(expected.map(matchMaker));
                const selfRef = selfReferences.get(expected);
                if (selfRef) {
                    selfRef.matcher = arrayMatcher;
                    return selfRef;
                }
                return arrayMatcher;
            }
            finally {
                references.delete(expected);
            }
        }
        if (PrettyPrinter_1.PrettyPrinter.isMock(expected)) {
            return IsEqualsMatcher_1.IsEqualsMatcher.make(expected);
        }
        if (ofType_1.ofType.isFunction(expected)) {
            return AnyMatcher_1.AnyMatcher.make();
        }
        if (ofType_1.ofType.isError(expected)) {
            return ErrorMatcher_1.ErrorMatcher.make(IsEqualsMatcher_1.IsEqualsMatcher.make(expected.message));
        }
        if (ofType_1.ofType.isSet(expected)) {
            return SetMatcher_1.SetMatcher.make(expected);
        }
        if (ofType_1.ofType.isMap(expected)) {
            return SetMatcher_1.SetMatcher.make(expected);
        }
        if (ofType_1.ofType.isObject(expected)) {
            const matcher = CustomiseMismatcher_1.CustomiseMismatcher.customMatcherWhenToUses
                .find(matcher => matcher.matches(expected).passed());
            if (matcher) {
                return CustomiseMismatcher_1.CustomiseMismatcher.customMatchers.get(matcher)(expected);
            }
            references.add(expected);
            try {
                const objectMatcher = ObjectMatcher_1.ObjectMatcher.make(expected);
                const selfRef = selfReferences.get(expected);
                if (selfRef) {
                    selfRef.matcher = objectMatcher;
                    return selfRef;
                }
                return objectMatcher;
            }
            finally {
                references.delete(expected);
            }
        }
        if (ofType_1.ofType.isRegExp(expected)) {
            return RegExpMatcher_1.RegExpMatcher.make(expected);
        }
        return IsEqualsMatcher_1.IsEqualsMatcher.make(expected);
    }
    finally {
        level -= 1;
        if (level === 0) {
            references.clear();
            selfReferences.clear();
        }
    }
}
exports.matchMaker = matchMaker;
class SelfReferenceMatcher extends DiffMatcher_1.DiffMatcher {
    constructor() {
        super();
        this.boundValue = undefined;
        this.specificity = 0; // todo
    }
    static make() {
        return new SelfReferenceMatcher();
    }
    mismatches(context, mismatched, actual) {
        if (this.boundValue === undefined) {
            this.boundValue = actual;
            const matchResult = this.matcher.matches(actual);
            if (matchResult.passed()) {
                return MatchResult_1.MatchResult.good(1);
            }
            mismatched.push(Mismatched_1.Mismatched.makeExpectedMessage(context, actual, this.describe()));
            return MatchResult_1.MatchResult.wasExpected(actual, this.describe(), 1, 0);
        }
        else {
            if (this.boundValue === actual) {
                return MatchResult_1.MatchResult.good(1);
            }
            else {
                mismatched.push(Mismatched_1.Mismatched.makeExpectedMessage(context, actual, this.describe()));
                return MatchResult_1.MatchResult.wasExpected(actual, this.describe(), 1, 0);
            }
        }
    }
    describe() {
        if (this.boundValue) {
            return { selfRefTo: this.boundValue };
        }
        return { selfRefTo: undefined };
    }
}
//# sourceMappingURL=matchMaker.js.map