"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assertThat_1 = require("../assertThat");
const IsEqualsMatcher_1 = require("../matcher/IsEqualsMatcher");
const match_1 = require("../match");
const ObjectMatcher_1 = require("../matcher/ObjectMatcher");
const RegExpMatcher_1 = require("../matcher/RegExpMatcher");
const matchMaker_1 = require("./matchMaker");
const StringMatcher_1 = require("../matcher/StringMatcher");
const index_1 = require("../index");
const AnyMatcher_1 = require("../matcher/AnyMatcher");
const PredicateMatcher_1 = require("../matcher/PredicateMatcher");
const CustomiseMismatcher_1 = require("./CustomiseMismatcher");
describe("matchMaker():", () => {
    const isEqualsMatcher = match_1.match.instanceOf(IsEqualsMatcher_1.IsEqualsMatcher);
    it("undefined", () => {
        (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)(undefined)).is(isEqualsMatcher);
    });
    it("null", () => {
        (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)(null)).is(isEqualsMatcher);
    });
    it("string", () => {
        (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)("a")).is(match_1.match.instanceOf(StringMatcher_1.StringMatcher));
    });
    it("number", () => {
        (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)(2)).is(isEqualsMatcher);
    });
    it("boolean", () => {
        (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)(true)).is(isEqualsMatcher);
    });
    it("symbol", () => {
        (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)(Symbol())).is(isEqualsMatcher);
    });
    it("matcher", () => {
        const matcher = match_1.match.isEquals(3);
        (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)(matcher)).is(isEqualsMatcher);
    });
    it("lambda", () => {
        (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)((a, b) => 3)).is(match_1.match.instanceOf((AnyMatcher_1.AnyMatcher)));
    });
    it("registered matcher", () => {
        class Hide {
            constructor(f, g, h) {
                this.f = f;
                this.g = g;
                this.h = h;
            }
            equals(other) {
                return this.f === other.f;
            }
        }
        const matcher = (expected) => PredicateMatcher_1.PredicateMatcher.make(value => expected.equals(value), { "Hide.equals": expected });
        CustomiseMismatcher_1.CustomiseMismatcher.addCustomMatcher(match_1.match.instanceOf(Hide), matcher);
        (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)(new Hide(1, 2, 3))).is(match_1.match.instanceOf(PredicateMatcher_1.PredicateMatcher));
    });
    describe("object", () => {
        it("anonymous class", () => {
            (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)({ a: 3 })).is(match_1.match.instanceOf(ObjectMatcher_1.ObjectMatcher));
        });
        it("known class", () => {
            (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)(new Date())).is(match_1.match.instanceOf(ObjectMatcher_1.ObjectMatcher));
        });
    });
    it("regExp", () => {
        (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)(/ab/)).is(match_1.match.instanceOf(RegExpMatcher_1.RegExpMatcher));
    });
    it("mock", () => {
        const pseudoMockSymbol = Symbol("pseudoMock");
        index_1.PrettyPrinter.make(80, 10, 100, pseudoMockSymbol); // register it
        const mock = new Proxy(() => 3, {
            get: (target, propKey, receiver) => {
                if (propKey === index_1.PrettyPrinter.symbolForMockName) {
                    return () => ({ mock: "mockName" });
                }
                return undefined;
            }
        });
        (0, assertThat_1.assertThat)((0, matchMaker_1.matchMaker)(mock)).is(match_1.match.instanceOf(IsEqualsMatcher_1.IsEqualsMatcher));
        (0, assertThat_1.assertThat)(mock).is(mock);
    });
    describe('self-reference', () => {
        it("self-reference to array at top level", () => {
            const a = [2];
            a[1] = a;
            // [2, <a>}]
            const a2 = [2];
            a2[1] = a2;
            (0, assertThat_1.assertThat)(a).is(a2);
        });
        it("self-references to array at top level", () => {
            const a = [2];
            a[1] = a;
            a[2] = a;
            // [2, <a>, <a>}]
            const a2 = [2];
            a2[1] = a2;
            a2[2] = a2;
            (0, assertThat_1.assertThat)(a).is(a2);
        });
        it("deeper self references", () => {
            const a = [[1]];
            a[1] = a[0];
            a[2] = a[0];
            // [[1], <a[0]>, <a[0]>]
            const a2 = [[1]];
            a2[1] = a2[0];
            a2[2] = a2[0];
            (0, assertThat_1.assertThat)(a).is(a2);
        });
        it("at top level", () => {
            const a = { b: 2 };
            a.c = a;
            // {b: 2, c: <a>}
            const a2 = { b: 2 };
            a2.c = a2;
            (0, assertThat_1.assertThat)(a).is(a2);
        });
        it("deeper level", () => {
            const a = { b: { c: 4 } };
            a.b.d = a.b;
            // {b: {c: 4, d: <a.b>}}
            (0, assertThat_1.assertThat)(a).is(a);
        });
        it("deeper level, twice", () => {
            const a = { b: { c: 4 } };
            a.b.d = a.b;
            a.e = { b: a.b };
            // {b: {c: 4, d: <a.b>}, e: {b: <a.b>}}
            (0, assertThat_1.assertThat)(a).is(a);
        });
        it("is ok as is, but could use the same self-reference technique", () => {
            const x = { f: 1 };
            const a = { b: { c: 4, x }, x };
            (0, assertThat_1.assertThat)(a).is(a);
        });
    });
});
//# sourceMappingURL=matchMaker.micro.js.map