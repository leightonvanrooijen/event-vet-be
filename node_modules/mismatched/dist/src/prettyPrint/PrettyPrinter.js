"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exceptionMessage = exports.cleanString = exports.PrettyPrinter = exports.defaultMaxTilesCount = exports.defaultMaxComplexity = exports.defaultLineWidth = void 0;
const ofType_1 = require("../ofType");
const Appender_1 = require("./Appender");
const SelfReferenceChecker_1 = require("./SelfReferenceChecker");
const PropertyName_1 = require("./PropertyName");
const SimpleTile_1 = require("./tile/SimpleTile");
const ArrayTile_1 = require("./tile/ArrayTile");
const PseudoCallTile_1 = require("./tile/PseudoCallTile");
const ObjectTile_1 = require("./tile/ObjectTile");
const allKeys_1 = require("../allKeys");
exports.defaultLineWidth = 80;
exports.defaultMaxComplexity = 30;
exports.defaultMaxTilesCount = 10000;
class PrettyPrinter {
    constructor(lineWidth, maxComplexity, maxTilesCount = exports.defaultMaxTilesCount) {
        this.lineWidth = lineWidth;
        this.maxComplexity = maxComplexity;
        this.maxTilesCount = maxTilesCount;
        this.selfReference = new SelfReferenceChecker_1.SelfReferenceChecker();
        this.tilesCount = 0;
    }
    static addCustomPrettyPrinter(matcher, toString) {
        this.customPrettyPrinters.set(matcher, toString);
    }
    static make(lineWidth = exports.defaultLineWidth, maxComplexity = exports.defaultMaxComplexity, maxTilesCount = exports.defaultMaxTilesCount, symbolForMockName) {
        if (symbolForMockName) {
            PrettyPrinter.symbolForMockName = symbolForMockName; // Just use the latest one
        }
        return new PrettyPrinter(lineWidth, maxComplexity, maxTilesCount);
    }
    static isMock(value) {
        return ofType_1.ofType.isFunction(value) &&
            PrettyPrinter.symbolForMockName &&
            !ofType_1.ofType.isUndefined(value[PrettyPrinter.symbolForMockName]);
    }
    static logToConsole(value) {
        return PrettyPrinter.make().logToConsole(value);
    }
    static logStackToConsole() {
        try {
            throw new Error('Grab Stack');
        }
        catch (e) {
            PrettyPrinter.logToConsole({ stack: e.stack });
        }
    }
    static functionDetails(fn) {
        try { // who knows when some weird JS will make this fail
            if (fn.toString) {
                let details = fn.toString();
                let fullFunction = false;
                if (details.startsWith("function ")) {
                    fullFunction = true;
                    details = details.substring("function ".length);
                }
                let bracket = details.indexOf(")");
                if (bracket < 0) {
                    bracket = 30;
                }
                details = details.substring(0, bracket + 1);
                if (fullFunction) {
                    return { function: details };
                }
                return { arrow: details };
            }
        }
        catch (e) {
        }
        return { function: "no details" };
    }
    render(value) {
        const appender = new Appender_1.Appender(this.lineWidth, this.maxComplexity);
        this.tile("this.", value).render(appender);
        return appender.compose();
    }
    logToConsole(value) {
        console.log(this.render(value));
    }
    tile(context, value) {
        this.tilesCount++;
        if (PrettyPrinter.isMock(value)) {
            const mockName = value[PrettyPrinter.symbolForMockName]();
            return this.tileObject(context, { mock: mockName });
        }
        if (ofType_1.ofType.isRegExp(value)) {
            return new SimpleTile_1.SimpleTile(value);
        }
        if (ofType_1.ofType.isSymbol(value)) {
            return new SimpleTile_1.SimpleTile(value.toString());
        }
        if (ofType_1.ofType.isString(value)) {
            return new SimpleTile_1.SimpleTile(cleanString(value));
        }
        if (ofType_1.ofType.isFunction(value)) {
            return this.tileObject(context, PrettyPrinter.functionDetails(value));
        }
        if (ofType_1.ofType.isArray(value)) {
            try {
                if (value.length > this.maxTilesCount - this.tilesCount) {
                    return new SimpleTile_1.SimpleTile("[... ********* this array has been truncated *********]");
                }
                const items = this.selfReference.recurse(context, value, () => value.map((v, i) => this.tile(context + "[" + i + "]", v)));
                return new ArrayTile_1.ArrayTile(items);
            }
            catch (e) {
                return new SimpleTile_1.SimpleTile((0, exports.exceptionMessage)(e));
            }
        }
        if (ofType_1.ofType.isObject(value)) {
            return this.tileObject(context, value);
        }
        return new SimpleTile_1.SimpleTile(value);
    }
    tileObject(context, value) {
        try {
            if (this.tilesCount > this.maxTilesCount) {
                return new SimpleTile_1.SimpleTile("... ********* this object has been truncated *********");
            }
            const callName = value[PrettyPrinter.symbolForPseudoCall];
            let valueArgs = value.args;
            if (callName && (ofType_1.ofType.isArray(valueArgs) || ofType_1.ofType.isUndefined(valueArgs))) {
                const args = valueArgs ? valueArgs.map((v, i) => this.tile(context + "[" + i + "]", v)) : undefined;
                return new PseudoCallTile_1.PseudoCallTile(callName, args);
            }
            if (value instanceof Date) {
                return new SimpleTile_1.SimpleTile('new Date(' + JSON.stringify(value) + ')');
            }
            if (value instanceof Set) {
                if (value.size > this.maxTilesCount - this.tilesCount) {
                    return new SimpleTile_1.SimpleTile("... ********* this set has been truncated *********");
                }
                return new PseudoCallTile_1.PseudoCallTile('new Set', Array.from(value).map(v => this.tile(context, v)), true);
            }
            if (value instanceof Map) {
                if (value.size > this.maxTilesCount - this.tilesCount) {
                    return new SimpleTile_1.SimpleTile("... ********* this map has been truncated *********");
                }
                return new PseudoCallTile_1.PseudoCallTile('new Map', Array.from(value.entries()).map(v => this.tile(context, v)), true);
            }
            if (value instanceof Error) {
                // Error doesn't have a proper property 'message'
                return this.tileObject(context, { errorMessage: value.message });
            }
            const matcher = Array.from(PrettyPrinter.customPrettyPrinters.keys())
                .find(matcher => matcher.matches(value).passed());
            if (matcher) {
                return new SimpleTile_1.SimpleTile(PrettyPrinter.customPrettyPrinters.get(matcher)(value));
            }
            const fields = this.selfReference.recurse(context, value, () => {
                let keys = (0, allKeys_1.allKeys)(value);
                if (keys.length > this.maxTilesCount - this.tilesCount) {
                    return [new ObjectTile_1.FieldTile("note", new SimpleTile_1.SimpleTile("... ********* this object has been truncated *********"))];
                }
                return keys.map(key => {
                    const renderedKey = PropertyName_1.PropertyName.render(key);
                    return new ObjectTile_1.FieldTile(renderedKey, this.tile(context + renderedKey, value[key]));
                });
            });
            return new ObjectTile_1.ObjectTile(fields);
        }
        catch (e) {
            return new SimpleTile_1.SimpleTile((0, exports.exceptionMessage)(e)); // todo Change this to an auto-coloured Tile
        }
    }
}
exports.PrettyPrinter = PrettyPrinter;
PrettyPrinter.symbolForPseudoCall = Symbol("pseudoCall");
PrettyPrinter.customPrettyPrinters = new Map();
function cleanString(value) {
    if (!value.includes(`"`)) {
        return `"` + value + `"`;
    }
    if (!value.includes(`'`)) {
        return `'` + value + `'`;
    }
    if (!value.includes('`')) {
        return '`' + value + '`';
    }
    return JSON.stringify(value);
}
exports.cleanString = cleanString;
const exceptionMessage = (e) => {
    if (e instanceof Error)
        return e.message;
    if (ofType_1.ofType.isString(e))
        return e;
    if (ofType_1.ofType.isFunction(e))
        return JSON.stringify(e);
    if (ofType_1.ofType.isObject(e))
        return JSON.stringify(e);
    if (ofType_1.ofType.isNull(e))
        return 'null';
    if (ofType_1.ofType.isUndefined(e))
        return 'undefined';
    return 'An unknown exception type';
};
exports.exceptionMessage = exceptionMessage;
//# sourceMappingURL=PrettyPrinter.js.map