"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertException = exports.ensureNotFunction = exports.assertThat = void 0;
const AnyOfMatcher_1 = require("./matcher/AnyOfMatcher");
const AllOfMatcher_1 = require("./matcher/AllOfMatcher");
const matchMaker_1 = require("./matchMaker/matchMaker");
const assert_1 = require("assert");
const match_1 = require("./match");
const ofType_1 = require("./ofType");
const PrettyPrinter_1 = require("./prettyPrint/PrettyPrinter");
const ErrorMatcher_1 = require("./matcher/ErrorMatcher");
function assertThat(actual) {
    return new Assertion(actual);
}
exports.assertThat = assertThat;
const printer = PrettyPrinter_1.PrettyPrinter.make();
class Assertion {
    constructor(actual) {
        this.actual = actual;
        this.message = "Mismatched";
    }
    withMessage(failMessage) {
        this.message = failMessage;
        return this;
    }
    is(expected) {
        this.checkForFunction();
        const result = this.match(expected);
        if (!result.passed()) {
            result.bad(this.actual, this.message);
        }
    }
    itIs(expected) {
        this.checkForFunction();
        return this.is(match_1.match.itIs(expected));
    }
    isNot(expected) {
        this.checkForFunction();
        return this.is(match_1.match.not((0, matchMaker_1.matchMaker)(expected)));
    }
    isAnyOf(expected) {
        this.checkForFunction();
        const result = AnyOfMatcher_1.AnyOfMatcher.make(expected).matches(this.actual);
        if (!result.passed()) {
            result.bad(this.actual, this.message);
        }
    }
    isAllOf(expected) {
        this.checkForFunction();
        const result = AllOfMatcher_1.AllOfMatcher.make(expected).matches(this.actual);
        if (!result.passed()) {
            result.bad(this.actual, this.message);
        }
    }
    // This is used internally for testing error messages:
    failsWith(expected, message) {
        const result = this.match(expected);
        if (result.passed()) {
            throw new Error('Did not expect it to pass');
        }
        const matchResult = assertThat(result.diff).match(message);
        if (!matchResult.passed()) {
            throw new Error(`Incorrect message: 
actual:   '${printer.render(result.diff)}' 
expected: '${printer.render(message)}'`);
        }
    }
    // This is used internally for testing error messages:
    failsWithRendering(expected, rendered) {
        const result = this.match(expected);
        assertThat(printer.render(result.diff)).is(rendered);
    }
    throws(expected = match_1.match.any()) {
        if (!ofType_1.ofType.isFunction(this.actual)) {
            throw new Error("Need to use the form: assertThat(()=> expression).throws('error')");
        }
        const matcher = (0, matchMaker_1.matchMaker)(expected);
        let passed = false;
        try {
            this.actual();
            passed = true;
        }
        catch (e) {
            const result = matcher.matches(e);
            if (!result.passed()) {
                result.bad((0, PrettyPrinter_1.exceptionMessage)(e));
            }
        }
        if (passed) {
            this.logExceptionFail("Expected an exception matching:", matcher);
            throw new Error("Problem in throws()");
        }
    }
    throwsError(message) {
        return this.throws(ErrorMatcher_1.ErrorMatcher.make(message));
    }
    catches(expected = match_1.match.any()) {
        const matcher = (0, matchMaker_1.matchMaker)(expected);
        const result = this.actual;
        assertThat(result).is(match_1.match.instanceOf(Promise));
        return result.then(() => true, e => {
            const result = matcher.matches(e);
            if (!result.passed()) {
                result.bad(e.message);
            }
            return false;
        }).then(passed => {
            if (passed) {
                this.logExceptionFail("Expected a promise.catch matching:", matcher);
                return Promise.reject("Problem in catches()");
            }
            return Promise.resolve();
        });
    }
    catchesError(message) {
        return this.catches(ErrorMatcher_1.ErrorMatcher.make(message));
    }
    logExceptionFail(message, matcher) {
        console.log(message, PrettyPrinter_1.PrettyPrinter.make().render(matcher.describe()));
    }
    match(expected) {
        const matcher = (0, matchMaker_1.matchMaker)(expected);
        return matcher.matches(this.actual);
    }
    checkForFunction() {
        ensureNotFunction(this.actual);
    }
}
function ensureNotFunction(actual) {
    if (ofType_1.ofType.isFunction(actual && !actual[PrettyPrinter_1.PrettyPrinter.symbolForMockName])) {
        throw new Error("Can't assertThat() on a function, as functions are not matched");
    }
}
exports.ensureNotFunction = ensureNotFunction;
function assertException(fn) {
    return new ExceptionAssertion(fn);
}
exports.assertException = assertException;
class ExceptionAssertion {
    constructor(fn) {
        this.fn = fn;
    }
    catchWithMessage(expected) {
        let failed = false;
        let result = undefined;
        try {
            result = this.fn();
            failed = true;
        }
        catch (e) {
            assertThat(e.message).is(expected);
        }
        if (failed) {
            (0, assert_1.fail)(`Failed to throw exception. Expecting ${expected} but got ${result}`);
        }
    }
    catch(expected) {
        let failed = false;
        let result = undefined;
        try {
            result = this.fn();
            failed = true;
        }
        catch (e) {
            assertThat(e).is(expected);
        }
        if (failed) {
            (0, assert_1.fail)(`Failed to throw exception. Expecting ${expected} but got ${result}`);
        }
    }
}
//# sourceMappingURL=assertThat.js.map