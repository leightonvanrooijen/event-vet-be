"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assertThat_1 = require("../assertThat");
const match_1 = require("../match");
const MatchResult_1 = require("../MatchResult");
const DiffFieldMatcher_1 = require("./DiffFieldMatcher");
const validateThat_1 = require("../validateThat");
describe("obj.some:", () => {
    describe("assertThat():", () => {
        describe('matches', () => {
            it('with explicit field matchers', () => {
                const actual = { f: 2, g: 3, h: 4 };
                let fieldMatcher1 = DiffFieldMatcher_1.DiffFieldMatcher.make("f", 2);
                let fieldMatcher2 = DiffFieldMatcher_1.DiffFieldMatcher.make("g", 3);
                (0, assertThat_1.assertThat)(actual).is(match_1.match.obj.has({ f: 2, g: 3 }));
            });
            it('literal object', () => {
                const actual = { f: 2, g: 3, h: 4 };
                (0, assertThat_1.assertThat)(actual).is(match_1.match.obj.has({ f: 2, g: 3 }));
            });
            it('empty object', () => {
                const actual = { f: 2, g: 3, h: 4 };
                (0, assertThat_1.assertThat)(actual).is(match_1.match.obj.has({}));
                (0, assertThat_1.assertThat)({}).is(match_1.match.obj.has({}));
            });
        });
        describe('does not match actual that is:', () => {
            it('an object', () => {
                const actual = { f: 2, g: 3 };
                const expected = match_1.match.obj.has({ f: 3 });
                (0, assertThat_1.assertThat)(actual).failsWith(expected, { f: { [MatchResult_1.MatchResult.was]: 2, [MatchResult_1.MatchResult.expected]: 3 } });
            });
            it('not an object', () => {
                const actual = 3;
                const expected = match_1.match.obj.has({ f: 3 });
                (0, assertThat_1.assertThat)(actual).failsWith(expected, { [MatchResult_1.MatchResult.was]: 3, [MatchResult_1.MatchResult.expected]: { "obj.has": { f: 3 } } });
            });
            it('undefined', () => {
                const actual = undefined;
                const expected = match_1.match.obj.has({ f: 3 });
                (0, assertThat_1.assertThat)(actual).failsWith(expected, { [MatchResult_1.MatchResult.expected]: { "obj.has": { f: 3 } } });
            });
        });
    });
    describe("validateThat():", () => {
        const expected = match_1.match.obj.has({ f: match_1.match.ofType.number(), g: match_1.match.ofType.boolean() });
        it("succeeds", () => {
            const validation = (0, validateThat_1.validateThat)({ f: 2, g: true, h: 45 }).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(true);
        });
        it("fails wrong types", () => {
            const validation = (0, validateThat_1.validateThat)({ f: "2", g: 3, h: 45 }).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                `{"actual.f": "2", expected: "ofType.number"}`,
                `{"actual.g": 3, expected: "ofType.boolean"}`
            ]);
        });
        it("fails to match", () => {
            const validation = (0, validateThat_1.validateThat)({ f: "2" }).satisfies({ f: 3 });
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                '{"actual.f": "2", expected: 3}'
            ]);
        });
    });
});
//# sourceMappingURL=ObjectSomeMatcher.micro.js.map