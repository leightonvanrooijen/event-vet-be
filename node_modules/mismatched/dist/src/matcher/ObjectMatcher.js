"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.concatObjects = exports.ObjectMatcher = void 0;
const DiffMatcher_1 = require("./DiffMatcher");
const ofType_1 = require("../ofType");
const MatchResult_1 = require("../MatchResult");
const Mismatched_1 = require("./Mismatched");
const DiffFieldMatcher_1 = require("./DiffFieldMatcher");
const allKeys_1 = require("../allKeys");
class ObjectMatcher extends DiffMatcher_1.DiffMatcher {
    constructor(expectedObject, fieldMatchers) {
        super();
        this.expectedObject = expectedObject;
        this.fieldMatchers = fieldMatchers;
        this.specificity = DiffMatcher_1.DiffMatcher.andSpecificity(fieldMatchers);
    }
    static make(obj) {
        return new ObjectMatcher(obj, DiffFieldMatcher_1.DiffFieldMatcher.makeAll(obj));
    }
    mismatches(context, mismatched, actual) {
        if (!ofType_1.ofType.isObject(actual)) {
            mismatched.push(Mismatched_1.Mismatched.makeExpectedMessage(context, actual, "object expected"));
            return MatchResult_1.MatchResult.wasExpected(actual, this.describe(), 1, 0);
        }
        if (this.expectedObject === actual) {
            return MatchResult_1.MatchResult.good(1, true);
        }
        const diff = {};
        let errors = 0;
        let compares = 0;
        let matches = 0;
        let matchedObjectKey = false;
        const keyMatchers = this.fieldMatchers.filter(m => m.isKey());
        if (keyMatchers.length > 0) {
            keyMatchers.forEach(e => {
                const result = e.mismatches(context, mismatched, actual);
                if (result.passed()) {
                    diff[e.fieldName] = actual[e.fieldName];
                }
                else {
                    diff[e.fieldName] = result.diff;
                    errors += 10;
                }
                compares += result.compares;
                matches += result.matchRate * result.compares;
            });
            if (errors === 0) {
                matchedObjectKey = true;
            }
        }
        const nonKeyMatchers = this.fieldMatchers.filter(m => !m.isKey());
        nonKeyMatchers.forEach(e => {
            const result = e.mismatches(context, mismatched, actual);
            if (result.passed()) {
                diff[e.fieldName] = actual[e.fieldName];
            }
            else {
                diff[e.fieldName] = result.diff;
                errors += 1;
            }
            compares += result.compares;
            matches += result.matchRate * result.compares;
        });
        const unexpected = {};
        let wasUnexpected = false;
        (0, allKeys_1.allKeys)(actual).forEach(key => {
            // Careful, as an actual field may have an explicit value of undefined:
            if (actual[key] !== undefined && !diff.hasOwnProperty(key)) {
                unexpected[key] = actual[key];
                errors += 1;
                compares += 1;
                wasUnexpected = true;
            }
        });
        compares = compares === 0 ? 1 : compares;
        if (wasUnexpected) {
            mismatched.push(Mismatched_1.Mismatched.makeUnexpectedMessage(context, actual, unexpected));
            diff[MatchResult_1.MatchResult.unexpected] = unexpected;
        }
        if (errors === 0) {
            return MatchResult_1.MatchResult.good(compares, matchedObjectKey);
        }
        return new MatchResult_1.MatchResult(diff, compares, matches, matchedObjectKey);
    }
    describe() {
        return concatObjects(this.fieldMatchers.map(e => e.describe()));
    }
    static allKeys(actual) {
        return Object.keys(actual)
            .concat(Object.getOwnPropertySymbols(actual));
    }
}
exports.ObjectMatcher = ObjectMatcher;
function concatObjects(objects) {
    const result = {};
    objects.forEach(o => (0, allKeys_1.allKeys)(o).forEach(key => result[key] = o[key]));
    return result;
}
exports.concatObjects = concatObjects;
//# sourceMappingURL=ObjectMatcher.js.map