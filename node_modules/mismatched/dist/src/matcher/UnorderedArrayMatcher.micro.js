"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assertThat_1 = require("../assertThat");
const match_1 = require("../match");
const MatchResult_1 = require("../MatchResult");
const validateThat_1 = require("../validateThat");
describe("unorderedArray:", () => {
    describe("match.array.unordered:", () => {
        describe("assertThat():", () => {
            it('matches when both empty', () => {
                (0, assertThat_1.assertThat)([]).is(match_1.match.array.unordered([]));
            });
            it('matches', () => {
                (0, assertThat_1.assertThat)([1, 2, 3]).is(match_1.match.array.unordered([1, 2, 3]));
                (0, assertThat_1.assertThat)([1, 2, 3]).is(match_1.match.array.unordered([2, 1, 3]));
                (0, assertThat_1.assertThat)([1, 2, 3]).is(match_1.match.array.unordered([3, 2, 1]));
                (0, assertThat_1.assertThat)([1, 1, 1]).is(match_1.match.array.unordered([1, 1, 1]));
                (0, assertThat_1.assertThat)([[1, 1], [2, 2], [3, 3]]).is(match_1.match.array.unordered([[1, 1], [2, 2], [3, 3]]));
                (0, assertThat_1.assertThat)([[3, 3], [1, 1], [2, 2], [1, 1]]).is(match_1.match.array.unordered([[1, 1], [1, 1], [2, 2], [3, 3]]));
            });
            it('matches match.any() last as lowest complexity', () => {
                (0, assertThat_1.assertThat)([1, 2, 3]).is(match_1.match.array.unordered([1, 2, match_1.match.any()]));
                (0, assertThat_1.assertThat)([1, 2, 3]).is(match_1.match.array.unordered([1, match_1.match.any(), 2]));
                (0, assertThat_1.assertThat)([1, 2, 3]).is(match_1.match.array.unordered([match_1.match.any(), 1, 2]));
                (0, assertThat_1.assertThat)([1, 2, 3]).is(match_1.match.array.unordered([2, 1, match_1.match.any()]));
                (0, assertThat_1.assertThat)([[1, 1], [2, 2], [3, 3]])
                    .is(match_1.match.array.unordered([[2, 2], [1, 1], match_1.match.ofType.array()]));
            });
            it('does not match: too many', () => {
                const actual = [1, 2, 3];
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.array.unordered([1, 2]), [1, 2, { [MatchResult_1.MatchResult.unexpected]: 3 }]);
            });
            it('does not match: too few', () => {
                const actual = [1, 2];
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.array.unordered([1, 2, 3]), [1, 2, { [MatchResult_1.MatchResult.expected]: 3 }]);
            });
            it('does not match: values mismatch', () => {
                const actual = [1, 2, 3];
                const expected = [1, 2, 4];
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.array.unordered(expected), [1, 2, { [MatchResult_1.MatchResult.was]: 3, [MatchResult_1.MatchResult.expected]: 4 }]);
            });
            it("does not match: no duplicated values", () => {
                (0, assertThat_1.assertThat)([1, 1, 1]).failsWith(match_1.match.array.unordered([1]), [1, { [MatchResult_1.MatchResult.unexpected]: 1 }, { [MatchResult_1.MatchResult.unexpected]: 1 }]);
            });
            it('matches the best first', () => {
                const actual = [{ a: 1, b: [0] }, { a: 11, b: [0] }];
                const expected = [{ a: 11, b: [1] }];
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.array.unordered(expected), [
                    { [MatchResult_1.MatchResult.unexpected]: { a: 1, b: [0] } },
                    { a: 11, b: [{ [MatchResult_1.MatchResult.unexpected]: 0 }, { [MatchResult_1.MatchResult.expected]: 1 }] }
                ]);
            });
            it('matches the best first deeply nested', () => {
                const actual = [{ a: 1, b: { c: [1] } }, { a: 11, b: { c: [2] } }];
                const expected = [{ a: 11, b: { c: [3] } }];
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.array.unordered(expected), [
                    { [MatchResult_1.MatchResult.unexpected]: { a: 1, b: { c: [1] } } },
                    { a: 11, b: { c: [{ [MatchResult_1.MatchResult.unexpected]: 2 }, { [MatchResult_1.MatchResult.expected]: 3 }] } }
                ]);
            });
        });
        describe("validateThat():", () => {
            const isNumber = match_1.match.ofType.number();
            const expected = [isNumber, [isNumber]];
            it("succeeds", () => {
                const actual = [1, [4]];
                const validation = (0, validateThat_1.validateThat)(actual).satisfies(match_1.match.array.unordered(expected));
                (0, assertThat_1.assertThat)(validation.errors).is([]);
                (0, assertThat_1.assertThat)(validation.passed()).is(true);
            });
            it("succeeds with general matcher", () => {
                const actual = [1, 2];
                const validation = (0, validateThat_1.validateThat)(actual).satisfies(match_1.match.array.unordered([1, match_1.match.any()]));
                (0, assertThat_1.assertThat)(validation.errors).is([]);
                (0, assertThat_1.assertThat)(validation.passed()).is(true);
            });
            it("fails as incorrect set", () => {
                const actual = [1, ["s"]];
                const validation = (0, validateThat_1.validateThat)(actual).satisfies(match_1.match.array.unordered(expected));
                (0, assertThat_1.assertThat)(validation.passed()).is(false);
                (0, assertThat_1.assertThat)(validation.errors).is([
                    '{"actual[1]": ["s"], unexpected: "s"}',
                    '{"actual[1]": ["s"], missing: "ofType.number"}'
                ]);
            });
            it("fails as not an array", () => {
                const validation = (0, validateThat_1.validateThat)(false).satisfies(match_1.match.array.unordered(expected));
                (0, assertThat_1.assertThat)(validation.passed()).is(false);
                (0, assertThat_1.assertThat)(validation.errors).is([
                    `{actual: false, expected: "array expected"}`
                ]);
            });
        });
    });
    describe("match.array.unorderedContains:", () => {
        describe("assertThat():", () => {
            it('contains', () => {
                const actual = [1, 2, 3];
                (0, assertThat_1.assertThat)(actual).is(match_1.match.array.unorderedContains([1, 2, 3]));
                (0, assertThat_1.assertThat)(actual).is(match_1.match.array.unorderedContains([1, 2]));
            });
            it('does not match: values differ', () => {
                const actual = [1, 2, 3];
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.array.unorderedContains([1, 4]), [1, { [MatchResult_1.MatchResult.was]: 2, [MatchResult_1.MatchResult.expected]: 4 }, 3]);
            });
            it('does not match: too many values expected', () => {
                const actual = [1, 2, 3];
                const expected = [1, 2, 3, 4];
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.array.unorderedContains(expected), [1, 2, 3, { [MatchResult_1.MatchResult.expected]: 4 }]);
            });
        });
        describe("validateThat():", () => {
            const isNumber = match_1.match.ofType.number();
            const expected = [isNumber, [isNumber]];
            it("succeeds", () => {
                const actual = [1, [4]];
                const validation = (0, validateThat_1.validateThat)(actual).satisfies(match_1.match.array.unorderedContains(expected));
                (0, assertThat_1.assertThat)(validation.errors).is([]);
                (0, assertThat_1.assertThat)(validation.passed()).is(true);
            });
            it("fails as incorrect set", () => {
                const actual = [1, ["s"]];
                const validation = (0, validateThat_1.validateThat)(actual).satisfies(match_1.match.array.unorderedContains(expected));
                (0, assertThat_1.assertThat)(validation.passed()).is(false);
                (0, assertThat_1.assertThat)(validation.errors).is([
                    '{"actual[1]": ["s"], unexpected: "s"}',
                    '{"actual[1]": ["s"], missing: "ofType.number"}'
                ]);
            });
        });
    });
});
//# sourceMappingURL=UnorderedArrayMatcher.micro.js.map