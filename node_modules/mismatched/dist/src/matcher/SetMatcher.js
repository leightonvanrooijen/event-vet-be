"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SetMatcher = void 0;
const DiffMatcher_1 = require("./DiffMatcher");
const Mismatched_1 = require("./Mismatched");
const MatchResult_1 = require("../MatchResult");
const __1 = require("..");
const ofType_1 = require("../ofType");
const UnorderedArrayMatcher_1 = require("./UnorderedArrayMatcher");
class SetMatcher extends DiffMatcher_1.DiffMatcher {
    constructor(matchers, subset) {
        super();
        this.matchers = matchers;
        this.subset = subset;
        this.unorderedArrayMatcher = new UnorderedArrayMatcher_1.UnorderedArrayMatcher(matchers, subset);
        this.specificity = this.unorderedArrayMatcher.specificity;
    }
    static make(expected, subset = false) {
        if (!expected.values || !ofType_1.ofType.isFunction(expected.values)) {
            throw new Error("SetMatcher needs a Set, Array or Map");
        }
        const elementMatchers = Array.from(expected.values()).map(e => (0, __1.matchMaker)(e));
        return new SetMatcher(elementMatchers, subset);
    }
    mismatches(context, mismatched, actual) {
        if (ofType_1.ofType.isSet(actual) || ofType_1.ofType.isArray(actual) || ofType_1.ofType.isMap(actual)) {
            const actualValues = Array.from(actual.values());
            return this.unorderedArrayMatcher.mismatches(context, mismatched, actualValues);
        }
        mismatched.push(Mismatched_1.Mismatched.makeExpectedMessage(context, actual, (this.subset ? "sub" : "") + "set expected"));
        return MatchResult_1.MatchResult.wasExpected(actual, this.describe(), 1, 0);
    }
    describe() {
        const set = this.matchers.map(e => e.describe());
        return this.subset ? { subset: set } : set;
    }
}
exports.SetMatcher = SetMatcher;
//# sourceMappingURL=SetMatcher.js.map