"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayEveryMatcher = void 0;
const DiffMatcher_1 = require("./DiffMatcher");
const Mismatched_1 = require("./Mismatched");
const MatchResult_1 = require("../MatchResult");
const util_1 = require("util");
const matchMaker_1 = require("../matchMaker/matchMaker");
class ArrayEveryMatcher extends DiffMatcher_1.DiffMatcher {
    constructor(expected) {
        super();
        this.expected = expected;
        this.specificity = expected.specificity;
    }
    mismatches(context, mismatched, actual) {
        if ((0, util_1.isArray)(actual)) {
            let corrects = 0;
            let compares = 0;
            let matches = 0;
            let i = 0;
            for (let a of actual) {
                const result = this.expected.mismatches(context.add("[" + i + "]"), mismatched, a);
                if (result.passed()) {
                    corrects += 1;
                }
                compares += result.compares;
                matches += result.matchRate * result.compares;
                i += 1;
            }
            if (corrects === actual.length) {
                return MatchResult_1.MatchResult.good(compares === 0 ? 1 : compares);
            }
            return MatchResult_1.MatchResult.wasExpected(actual, this.describe(), compares, matches);
        }
        mismatched.push(Mismatched_1.Mismatched.makeExpectedMessage(context, actual, "array expected"));
        return MatchResult_1.MatchResult.wasExpected(actual, this.describe(), 1, 0);
    }
    describe() {
        return { "array.every": this.expected.describe() };
    }
    static make(expected) {
        return new ArrayEveryMatcher((0, matchMaker_1.matchMaker)(expected));
    }
}
exports.ArrayEveryMatcher = ArrayEveryMatcher;
//# sourceMappingURL=ArrayEveryMatcher.js.map