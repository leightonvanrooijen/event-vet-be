"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BindMatcher = void 0;
const DiffMatcher_1 = require("./DiffMatcher");
const MatchResult_1 = require("../MatchResult");
const matchMaker_1 = require("../matchMaker/matchMaker");
class BindMatcher extends DiffMatcher_1.DiffMatcher {
    constructor(matcher) {
        super();
        this.matcher = matcher;
        this.boundValueMatcher = undefined;
        this.specificity = -5; // Delay matching this, all else being equal
    }
    static make(matcher) {
        return new BindMatcher(matcher ? (0, matchMaker_1.matchMaker)(matcher) : undefined);
    }
    // Doesn't save the binding when we running a trial
    mismatches(context, mismatched, actual) {
        if (this.boundValueMatcher === undefined) {
            if (this.matcher) {
                const result = this.matcher.mismatches(context, mismatched, actual);
                if (!context.trialMatch && result.passed()) {
                    this.boundValueMatcher = (0, matchMaker_1.matchMaker)(actual);
                }
                return result;
            }
            else {
                if (!context.trialMatch) {
                    this.boundValueMatcher = (0, matchMaker_1.matchMaker)(actual);
                }
                return MatchResult_1.MatchResult.good(1);
            }
        }
        return this.boundValueMatcher.mismatches(context, mismatched, actual);
    }
    describe() {
        if (this.boundValueMatcher) {
            return { boundTo: this.boundValueMatcher.describe() };
        }
        if (this.matcher) {
            return { boundTo: this.matcher.describe() };
        }
        return { boundTo: undefined };
    }
}
exports.BindMatcher = BindMatcher;
//# sourceMappingURL=BindMatcher.js.map