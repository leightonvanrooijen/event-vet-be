"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assertThat_1 = require("../assertThat");
const match_1 = require("../match");
const MatchResult_1 = require("../MatchResult");
const DiffMatcher_1 = require("./DiffMatcher");
const validateThat_1 = require("../validateThat");
describe("AnyOfMatcher:", () => {
    describe("assertThat():", () => {
        it("Matches", () => {
            (0, assertThat_1.assertThat)(new Date()).isAnyOf([match_1.match.isEquals(3), match_1.match.instanceOf(Date)]);
            (0, assertThat_1.assertThat)({ a: 2 }).isAnyOf([match_1.match.instanceOf(Object)]);
            (0, assertThat_1.assertThat)({ a: 2 }).isAnyOf([match_1.match.instanceOf(Object)]);
        });
        it("Mismatches", () => {
            (0, assertThat_1.assertThat)({ a: 2 }).isNot(match_1.match.anyOf([])); // Base case of nothing matching
            (0, assertThat_1.assertThat)("ab")
                .failsWith(match_1.match.anyOf([match_1.match.instanceOf(Date)]), { [MatchResult_1.MatchResult.was]: "ab", [MatchResult_1.MatchResult.expected]: { instanceOf: "Date" } });
        });
        it("Mismatches with multiple anyOf", () => {
            (0, assertThat_1.assertThat)("ab").failsWith(match_1.match.anyOf([match_1.match.instanceOf(Date), match_1.match.instanceOf(Date)]), match_1.match.any());
            (0, assertThat_1.assertThat)({ f: "ab", g: 3 })
                .failsWith(match_1.match.anyOf([match_1.match.instanceOf(Date), { f: "a", g: 3 }]), { [MatchResult_1.MatchResult.was]: { f: "ab", g: 3 }, [MatchResult_1.MatchResult.expected]: { f: "a", g: 3 } });
        });
        it("Mismatches: errors", () => {
            const mismatched = [];
            const matcher = match_1.match.anyOf([match_1.match.instanceOf(Date), match_1.match.instanceOf(Error)]);
            matcher.mismatches(new DiffMatcher_1.ContextOfValidationError(), mismatched, "ab");
            (0, assertThat_1.assertThat)(mismatched).is([
                { actual: "ab", expected: { anyOf: [{ instanceOf: "Date" }, { instanceOf: "Error" }] } }
            ]);
        });
        it("Optimise away with a single matcher inside", () => {
            const whatever = match_1.match.ofType.array();
            (0, assertThat_1.assertThat)(match_1.match.anyOf([whatever])).is(match_1.match.itIs(whatever));
        });
    });
    describe("validateThat():", () => {
        const expected = match_1.match.anyOf([
            match_1.match.instanceOf(Date),
            match_1.match.ofType.number()
        ]);
        it("succeeds", () => {
            const validation = (0, validateThat_1.validateThat)(3).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(true);
        });
        it("fails", () => {
            const validation = (0, validateThat_1.validateThat)(false).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                `{actual: false, expected: {anyOf: [{instanceOf: "Date"}, "ofType.number"]}}`
            ]);
        });
        it("fails and just mentions the single match that was close", () => {
            const expected = match_1.match.anyOf([
                match_1.match.instanceOf(Date),
                { f: 3, g: 4 }
            ]);
            const validation = (0, validateThat_1.validateThat)({ f: 3 }).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                '[{"actual.g": undefined, expected: 4}]'
            ]);
        });
        it("Just mentions the failures to match within the single key match", () => {
            const matchTypeA = { type: match_1.match.obj.key('a'), f: match_1.match.ofType.string() };
            const matchTypeB = { type: match_1.match.obj.key('b'), f: match_1.match.ofType.number() };
            const actual = { type: 'a', f: 4 };
            const validation = (0, validateThat_1.validateThat)(actual).satisfies(match_1.match.anyOf([matchTypeA, matchTypeB]));
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                '[{"actual.f": 4, expected: "ofType.string"}]'
            ]);
        });
        it("Just mentions the failures to match within the single key match with some", () => {
            const matchTypeA = match_1.match.obj.has({ type: match_1.match.obj.key('a'), f: match_1.match.ofType.string() });
            const matchTypeB = match_1.match.obj.has({ type: match_1.match.obj.key('b'), f: match_1.match.ofType.number() });
            const actual = { type: 'a', f: 4 };
            const validation = (0, validateThat_1.validateThat)(actual).satisfies(match_1.match.anyOf([matchTypeA, matchTypeB]));
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                '[{"actual.f": 4, expected: "ofType.string"}]'
            ]);
        });
        it("Just mentions the failures to match within the single key match nested", () => {
            const extra = { id: match_1.match.any() };
            const matchTypeA = Object.assign(Object.assign({}, extra), { type: match_1.match.obj.key('a'), f: match_1.match.ofType.string() });
            const matchTypeB = Object.assign(Object.assign({}, extra), { type: match_1.match.obj.key('b'), f: match_1.match.ofType.number() });
            const actual = { x: true, b: { a: { id: 3, type: 'a', f: 4 } } };
            const validation = (0, validateThat_1.validateThat)(actual).satisfies({
                x: match_1.match.any(),
                b: { a: match_1.match.anyOf([matchTypeA, matchTypeB]) }
            });
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                '[{"actual.b.a.f": 4, expected: "ofType.string"}]'
            ]);
        });
        it("fails with no key", () => {
            const expected = match_1.match.anyOf([
                { type: 'a', f: 3 },
                { type: 'b', f: 4 }
            ]);
            const validation = (0, validateThat_1.validateThat)({ type: 'a', f: 4 }).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                '{actual: {type: "a", f: 4}, expected: {anyOf: [{type: "a", f: 3}, {type: "b", f: 4}]}}'
            ]);
        });
    });
});
//# sourceMappingURL=AnyOfMatcher.micro.js.map