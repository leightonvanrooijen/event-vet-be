"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assertThat_1 = require("../assertThat");
const match_1 = require("../match");
const validateThat_1 = require("../validateThat");
describe("OfTypeMatcher:", () => {
    describe("assertThat():", () => {
        it("ofType.array()", () => {
            (0, assertThat_1.assertThat)([]).is(match_1.match.ofType.array());
            (0, assertThat_1.assertThat)([1, 3]).is(match_1.match.ofType.array());
            (0, assertThat_1.assertThat)(2).is(match_1.match.not(match_1.match.ofType.array()));
        });
        it("ofType.function()", () => {
            (0, assertThat_1.assertThat)(() => 1).is(match_1.match.ofType.function());
            (0, assertThat_1.assertThat)((a, b) => a + b).is(match_1.match.ofType.function());
            (0, assertThat_1.assertThat)(2).is(match_1.match.not(match_1.match.ofType.function()));
        });
        it("ofType.string()", () => {
            (0, assertThat_1.assertThat)("").is(match_1.match.ofType.string());
            (0, assertThat_1.assertThat)("aa").is(match_1.match.ofType.string());
            (0, assertThat_1.assertThat)(2).is(match_1.match.not(match_1.match.ofType.string()));
        });
        it("ofType.number()", () => {
            (0, assertThat_1.assertThat)(1).is(match_1.match.ofType.number());
            (0, assertThat_1.assertThat)(2.3).is(match_1.match.ofType.number());
            (0, assertThat_1.assertThat)(true).is(match_1.match.not(match_1.match.ofType.number()));
        });
        it("ofType.boolean()", () => {
            (0, assertThat_1.assertThat)(true).is(match_1.match.ofType.boolean());
            (0, assertThat_1.assertThat)(false).is(match_1.match.ofType.boolean());
            (0, assertThat_1.assertThat)(1).is(match_1.match.not(match_1.match.ofType.boolean()));
        });
        it("ofType.regExp()", () => {
            (0, assertThat_1.assertThat)(/a/).is(match_1.match.ofType.regExp());
            (0, assertThat_1.assertThat)(/a.*/).is(match_1.match.ofType.regExp());
            (0, assertThat_1.assertThat)(1).is(match_1.match.not(match_1.match.ofType.regExp()));
        });
        it("ofType.symbol()", () => {
            (0, assertThat_1.assertThat)(Symbol("")).is(match_1.match.ofType.symbol());
            (0, assertThat_1.assertThat)(Symbol()).is(match_1.match.ofType.symbol());
            (0, assertThat_1.assertThat)(1).is(match_1.match.not(match_1.match.ofType.symbol()));
        });
        it('ofType.enum()', () => {
            let E;
            (function (E) {
                E["First"] = "First";
                E["Second"] = "Second";
            })(E || (E = {}));
            (0, assertThat_1.assertThat)(E.First).is(match_1.match.ofType.enum(E, "E"));
            (0, assertThat_1.assertThat)(E.Second).is(match_1.match.ofType.enum(E, "E"));
            (0, assertThat_1.assertThat)("junk").isNot(match_1.match.ofType.enum(E, "E"));
            (0, assertThat_1.assertThat)(undefined).isNot(match_1.match.ofType.enum(E, "E"));
            (0, assertThat_1.assertThat)(null).isNot(match_1.match.ofType.enum(E, "E"));
            (0, assertThat_1.assertThat)(false).isNot(match_1.match.ofType.enum(E, "E"));
            (0, assertThat_1.assertThat)(0).isNot(match_1.match.ofType.enum(E, "E"));
            (0, assertThat_1.assertThat)([]).isNot(match_1.match.ofType.enum(E, "E"));
            (0, assertThat_1.assertThat)({}).isNot(match_1.match.ofType.enum(E, "E"));
        });
    });
    describe("validateThat():", () => {
        const expected = match_1.match.ofType.number();
        it("succeeds", () => {
            const validation = (0, validateThat_1.validateThat)(3).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(true);
        });
        it("fails", () => {
            const validation = (0, validateThat_1.validateThat)(false).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                `{actual: false, expected: "ofType.number"}`
            ]);
        });
    });
});
//# sourceMappingURL=OfTypeMatcher.micro.js.map