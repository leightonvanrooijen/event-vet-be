"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assertThat_1 = require("../assertThat");
const match_1 = require("../match");
const MatchResult_1 = require("../MatchResult");
const ErrorMatcher_1 = require("./ErrorMatcher");
const DiffMatcher_1 = require("./DiffMatcher");
describe("ErrorMatcher()", () => {
    it("matches", () => {
        (0, assertThat_1.assertThat)(new Error("abc")).is(ErrorMatcher_1.ErrorMatcher.make("abc"));
        (0, assertThat_1.assertThat)(new Error("abc")).is(new Error("abc"));
    });
    it("mismatches", () => {
        const error = new Error("A");
        (0, assertThat_1.assertThat)(error).failsWith(ErrorMatcher_1.ErrorMatcher.make("abc"), {
            [MatchResult_1.MatchResult.was]: match_1.match.predicate(v => v === error),
            [MatchResult_1.MatchResult.expected]: { errorMessage: "abc" }
        });
        (0, assertThat_1.assertThat)(33).failsWith(ErrorMatcher_1.ErrorMatcher.make("abc"), { [MatchResult_1.MatchResult.was]: 33, [MatchResult_1.MatchResult.expected]: { instanceOf: "Error" } });
    });
    it("mismatches: errors", () => {
        const mismatched = [];
        const matcher = ErrorMatcher_1.ErrorMatcher.make("abc");
        matcher.mismatches(new DiffMatcher_1.ContextOfValidationError(), mismatched, new Error("A"));
        (0, assertThat_1.assertThat)(mismatched).is([
            { actual: "A", expected: "abc" }
        ]);
    });
});
//# sourceMappingURL=ErrorMatcher.micro.js.map