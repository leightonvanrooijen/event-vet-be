"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assertThat_1 = require("../assertThat");
const match_1 = require("../match");
const MatchResult_1 = require("../MatchResult");
const DiffMatcher_1 = require("./DiffMatcher");
const validateThat_1 = require("../validateThat");
const ArrayMatcher_1 = require("./ArrayMatcher");
describe("array.match:", () => {
    describe("assertThat():", () => {
        it('matches with undefined and null', () => {
            const actual = [2, undefined, null];
            (0, assertThat_1.assertThat)(actual).is([2, undefined, null]);
        });
        it('matches with an empty array', () => {
            (0, assertThat_1.assertThat)([]).is([]);
        });
        describe("Primitive values only", () => {
            it('matches', () => {
                const actual = [2, 2, 2];
                (0, assertThat_1.assertThat)(actual).is([2, 2, 2]);
            });
            it('Actual longer: unexpected', () => {
                const actual = ["a", "b", "c", "d"];
                const expected = ["a", "c"];
                (0, assertThat_1.assertThat)(actual).failsWith(expected, [
                    "a",
                    { [MatchResult_1.MatchResult.unexpected]: "b" },
                    "c",
                    { [MatchResult_1.MatchResult.unexpected]: "d" }
                ]);
                const matcher = ArrayMatcher_1.ArrayMatcher.make(expected);
                const result = matcher.matches(actual);
                (0, assertThat_1.assertThat)(result.matchRate).is(0.5);
            });
            it('Expected longer: expected', () => {
                const actual = ["c", "d"];
                const expected = ["a", "b", "c", "d"];
                (0, assertThat_1.assertThat)(actual).failsWith(expected, [{ [MatchResult_1.MatchResult.expected]: "a" }, { [MatchResult_1.MatchResult.expected]: "b" }, "c", "d"]);
                const matcher = ArrayMatcher_1.ArrayMatcher.make(expected);
                const result = matcher.matches(actual);
                (0, assertThat_1.assertThat)(result.matchRate).is(0.5);
            });
            it('Various differences, including in order: unexpected and expected', () => {
                const actual = ["b", "x", "y"];
                const expected = ["a", "b", "c", "x"];
                (0, assertThat_1.assertThat)(actual).failsWith(expected, [
                    { [MatchResult_1.MatchResult.expected]: "a" }, "b", { [MatchResult_1.MatchResult.expected]: "c" }, "x",
                    { [MatchResult_1.MatchResult.unexpected]: "y" }
                ]);
                const matcher = ArrayMatcher_1.ArrayMatcher.make(expected);
                const result = matcher.matches(actual);
                (0, assertThat_1.assertThat)(result.matchRate).is(0.4);
            });
            it('does not match: length difference: errors', () => {
                const mismatched = [];
                const matcher = match_1.match.array.match(["a", "b", "c"]);
                matcher.mismatches(new DiffMatcher_1.ContextOfValidationError(), mismatched, ["a", "b"]);
                (0, assertThat_1.assertThat)(mismatched).is([
                    { actual: ["a", "b"], missing: "c" }
                ]);
            });
        });
        it('Other differences', () => {
            (0, assertThat_1.assertThat)([{ b: "b" }, ["x"], "y"]).failsWith([{ a: "a" }, { b: "b" }, "c", ["x"]], [{ [MatchResult_1.MatchResult.expected]: { a: "a" } }, { b: "b" }, { [MatchResult_1.MatchResult.expected]: "c" }, ["x"],
                { [MatchResult_1.MatchResult.unexpected]: "y" }]);
        });
        it('matches the best first (sub)', () => {
            (0, assertThat_1.assertThat)([{ a: 11, b: [0] }]).failsWith([{ a: 11, b: [1] }], [{ a: 11, b: [{ [MatchResult_1.MatchResult.unexpected]: 0 }, { [MatchResult_1.MatchResult.expected]: 1 }] }]);
        });
        it('does not match: values mismatch', () => {
            const actual = ["a", "b"];
            const expected = ["a", "c"];
            (0, assertThat_1.assertThat)(actual).failsWith(expected, ["a", { [MatchResult_1.MatchResult.unexpected]: "b" }, { [MatchResult_1.MatchResult.expected]: "c" }]);
        });
        it('does not match: values mismatch: errors', () => {
            const mismatched = [];
            const matcher = match_1.match.array.match(["a", "c"]);
            matcher.mismatches(new DiffMatcher_1.ContextOfValidationError(), mismatched, ["a", "b"]);
            (0, assertThat_1.assertThat)(mismatched).is([
                { actual: ["a", "b"], unexpected: "b" },
                { actual: ["a", "b"], missing: "c" }
            ]);
        });
        it('matches literally nested', () => {
            const actual = [2, 2, [3, [4]]];
            (0, assertThat_1.assertThat)(actual).is([2, 2, [3, [4]]]);
        });
        it('does not match literally nested', () => {
            const actual = [1, 2, [3, [5]]];
            (0, assertThat_1.assertThat)(actual).failsWith([2, 2, [3, [4, 6]]], [
                { [MatchResult_1.MatchResult.unexpected]: 1 },
                { [MatchResult_1.MatchResult.expected]: 2 },
                2,
                [3, { [MatchResult_1.MatchResult.unexpected]: [5] }, { [MatchResult_1.MatchResult.expected]: [4, 6] }]
            ]);
            (0, assertThat_1.assertThat)(actual).failsWith([1, 2, [3, [6]]], [1, 2, [3, { [MatchResult_1.MatchResult.unexpected]: [5] }, { [MatchResult_1.MatchResult.expected]: [6] }]]);
        });
        it('does not match literally nested: errors', () => {
            const mismatched = [];
            const matcher = match_1.match.array.match([2, 2, [3, [5, 6]]]);
            matcher.mismatches(new DiffMatcher_1.ContextOfValidationError(), mismatched, [1, 2, [3, [5]]]);
            (0, assertThat_1.assertThat)(mismatched).is([
                { actual: [1, 2, [3, [5]]], unexpected: 1 },
                { actual: [1, 2, [3, [5]]], missing: 2 },
                { "actual[2][1]": [5], missing: 6 }
            ]);
        });
        it('does not match literally nested - wrong type', () => {
            const actual = [1, 2, [3, [5]]];
            let expected = [1, 2, [3, "a"]];
            (0, assertThat_1.assertThat)(actual).failsWith(expected, [1, 2, [3, { [MatchResult_1.MatchResult.unexpected]: [5] }, { [MatchResult_1.MatchResult.expected]: "a" }]]);
            (0, assertThat_1.assertThat)(expected).failsWith(actual, [1, 2, [3, { [MatchResult_1.MatchResult.unexpected]: "a" }, { [MatchResult_1.MatchResult.expected]: [5] }]]);
        });
        it("uses match.bind() to check for two values the same", () => {
            const value = {
                colours: [
                    { id: "615fa1d3-2c79-4f46-a06a-0d04cdc9c0eb", type: "Red" },
                    { id: "615fa1d3-2c79-4f46-a06a-0d04cdc9c0eb", type: "Red" },
                ]
            };
            const bindColour = match_1.match.bind(match_1.match.ofType.object());
            (0, assertThat_1.assertThat)(value).is({
                colours: [
                    bindColour,
                    bindColour
                ]
            });
        });
    });
    describe("validateThat():", () => {
        const isNumber = match_1.match.ofType.number();
        const expected = [isNumber, isNumber, [isNumber, [isNumber]]];
        it("succeeds with an empty array", () => {
            const validation = (0, validateThat_1.validateThat)([]).satisfies([]);
            (0, assertThat_1.assertThat)(validation.passed()).is(true);
        });
        it("succeeds", () => {
            const validation = (0, validateThat_1.validateThat)([1, 2, [3, [4]]]).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(true);
        });
        it("fails as element missing", () => {
            const expected = [isNumber];
            const validation = (0, validateThat_1.validateThat)([]).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                '{actual: [], missing: "ofType.number"}'
            ]);
        });
        it("fails as element unexpectedly present", () => {
            const expected = [];
            const validation = (0, validateThat_1.validateThat)([1]).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                '{actual: [1], unexpected: 1}'
            ]);
        });
        it("fails as incorrect array, simple", () => {
            const expected = [isNumber];
            const validation = (0, validateThat_1.validateThat)(["s"]).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                '{actual: ["s"], unexpected: "s"}',
                '{actual: ["s"], missing: "ofType.number"}'
            ]);
        });
        it("fails as incorrect array, less simple", () => {
            const validation = (0, validateThat_1.validateThat)([1, 2, [3, ["s"]]]).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                '{"actual[2]": [3, ["s"]], unexpected: ["s"]}',
                '{"actual[2]": [3, ["s"]], missing: ["ofType.number"]}'
            ]);
        });
        it("fails as incorrect array with nested arrays", () => {
            const validation = (0, validateThat_1.validateThat)([undefined, 2, [3, ["s"]]]).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                '{actual: [undefined, 2, [3, ["s"]]], unexpected: undefined}',
                '{actual: [undefined, 2, [3, ["s"]]], missing: "ofType.number"}',
                '{"actual[2]": [3, ["s"]], unexpected: ["s"]}',
                '{"actual[2]": [3, ["s"]], missing: ["ofType.number"]}'
            ]);
        });
        it("fails as not an array", () => {
            const validation = (0, validateThat_1.validateThat)(false).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                `{actual: false, expected: "array expected"}`
            ]);
        });
    });
});
//# sourceMappingURL=ArrayMatcher.micro.js.map