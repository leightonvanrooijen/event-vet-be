"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectSomeMatcher = void 0;
const DiffMatcher_1 = require("./DiffMatcher");
const Mismatched_1 = require("./Mismatched");
const MatchResult_1 = require("../MatchResult");
const ofType_1 = require("../ofType");
const ObjectMatcher_1 = require("./ObjectMatcher");
const DiffFieldMatcher_1 = require("./DiffFieldMatcher");
class ObjectSomeMatcher extends DiffMatcher_1.DiffMatcher {
    constructor(matchers) {
        super();
        this.matchers = matchers;
        this.specificity = DiffMatcher_1.DiffMatcher.andSpecificity(matchers);
    }
    static make(expected) {
        return new ObjectSomeMatcher(DiffFieldMatcher_1.DiffFieldMatcher.makeAll(expected));
    }
    mismatches(context, mismatched, actual) {
        if (!ofType_1.ofType.isObject(actual)) {
            mismatched.push(Mismatched_1.Mismatched.makeExpectedMessage(context, actual, "object expected"));
            return MatchResult_1.MatchResult.wasExpected(actual, this.describe(), 1, 0);
        }
        if (this.matchers.length === 0) // Succeeds as subset
            return new MatchResult_1.MatchResult([], 1, 1, false);
        const results = {};
        let errors = 0;
        let compares = 0;
        let matches = 0;
        let matchedObjectKey = false;
        const keyMatchers = this.matchers.filter(m => m.isKey());
        if (keyMatchers.length > 0) {
            keyMatchers.forEach(e => {
                const result = e.mismatches(context, mismatched, actual);
                if (result.passed()) {
                    results[e.fieldName] = actual[e.fieldName];
                }
                else {
                    results[e.fieldName] = result.diff;
                    errors += 10;
                }
                compares += result.compares;
                matches += result.matchRate * result.compares;
            });
            if (errors === 0) {
                matchedObjectKey = true;
            }
        }
        const nonKeyMatchers = this.matchers.filter(m => !m.isKey());
        nonKeyMatchers.forEach(e => {
            const result = e.mismatches(context, mismatched, actual);
            if (result.passed()) {
                results[e.fieldName] = actual[e.fieldName];
            }
            else {
                results[e.fieldName] = result.diff;
            }
            compares += result.compares;
            matches += result.matchRate * result.compares;
        });
        return new MatchResult_1.MatchResult(results, compares, matches, matchedObjectKey);
    }
    describe() {
        return { "obj.has": (0, ObjectMatcher_1.concatObjects)(this.matchers.map(e => e.describe())) };
    }
}
exports.ObjectSomeMatcher = ObjectSomeMatcher;
//# sourceMappingURL=ObjectSomeMatcher.js.map