"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringMatcher = exports.StringMatcher = void 0;
const DiffMatcher_1 = require("./DiffMatcher");
const MatchResult_1 = require("../MatchResult");
const ofType_1 = require("../ofType");
const PredicateMatcher_1 = require("./PredicateMatcher");
const Mismatched_1 = require("./Mismatched");
const RegExpMatcher_1 = require("./RegExpMatcher");
const StringDiff_1 = require("../diff/StringDiff");
const minimum = 5;
class StringMatcher extends DiffMatcher_1.DiffMatcher {
    constructor(expected) {
        super();
        this.expected = expected;
    }
    static make(expected) {
        return new StringMatcher(expected);
    }
    mismatches(context, mismatched, actual) {
        if (ofType_1.ofType.isString(actual)) {
            if (actual == this.expected) {
                return MatchResult_1.MatchResult.good(1);
            }
        }
        else {
            mismatched.push(Mismatched_1.Mismatched.makeExpectedMessage(context, actual, this.expected));
            return MatchResult_1.MatchResult.wasExpected(actual, this.expected, 1, 0);
        }
        mismatched.push(Mismatched_1.Mismatched.makeExpectedMessage(context, actual, this.describe()));
        const deltas = StringDiff_1.stringDiff.getPatch(this.expected, actual);
        const { totalAddLength, totalRemoveLength } = StringDiff_1.stringDiff.lengths(deltas);
        const rating = matchRating(actual.length, totalRemoveLength) +
            matchRating(this.expected.length, totalAddLength);
        const matchResult = MatchResult_1.MatchResult.wasExpected(actual, this.describe(), 1, rating);
        if (ofType_1.ofType.isString(actual)) {
            if (actual.length > 0 && this.expected.length > 0 &&
                (actual.length > minimum || this.expected.length > minimum) &&
                (totalRemoveLength < actual.length || totalAddLength < this.expected.length)) {
                matchResult.differ(StringDiff_1.stringDiff.differ(deltas, Array.from(actual)));
            }
        }
        return matchResult;
    }
    describe() {
        return this.expected;
    }
}
exports.StringMatcher = StringMatcher;
const uuidRegExp = /^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$/;
exports.stringMatcher = {
    match: (expected) => ofType_1.ofType.isString(expected) ? StringMatcher.make(expected) : RegExpMatcher_1.RegExpMatcher.make(expected),
    startsWith: (expected) => PredicateMatcher_1.PredicateMatcher.make(value => ofType_1.ofType.isString(value) && value.startsWith(expected), { "string.startsWith": expected }),
    endsWith: (expected) => PredicateMatcher_1.PredicateMatcher.make(value => ofType_1.ofType.isString(value) && value.endsWith(expected), { "string.endsWith": expected }),
    includes: (expected) => PredicateMatcher_1.PredicateMatcher.make(value => ofType_1.ofType.isString(value) && value.includes(expected), { "string.includes": expected }),
    uuid: () => PredicateMatcher_1.PredicateMatcher.make(value => ofType_1.ofType.isString(value) && value.match(uuidRegExp) !== null, "uuid"),
};
const matchRating = (length, totalLength) => length > 0 ? (length - totalLength) / (length * 2) : 0;
//# sourceMappingURL=StringMatcher.js.map