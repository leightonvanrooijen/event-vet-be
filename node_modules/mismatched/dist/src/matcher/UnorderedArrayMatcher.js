"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnorderedArrayMatcher = void 0;
const DiffMatcher_1 = require("./DiffMatcher");
const Mismatched_1 = require("./Mismatched");
const MatchResult_1 = require("../MatchResult");
const __1 = require("..");
const ofType_1 = require("../ofType");
class UnorderedArrayMatcher extends DiffMatcher_1.DiffMatcher {
    constructor(matchers, subset) {
        super();
        this.matchers = matchers;
        this.subset = subset;
        this.specificity = DiffMatcher_1.DiffMatcher.andSpecificity(matchers);
        matchers.sort((a, b) => b.specificity - a.specificity);
    }
    static make(expected, subset = false) {
        if (!expected.values || !ofType_1.ofType.isFunction(expected.values)) {
            throw new Error("UnorderedArrayMatcher needs an Array, Set or Map");
        }
        const elementMatchers = Array.from(expected.values()).map(e => (0, __1.matchMaker)(e));
        return new UnorderedArrayMatcher(elementMatchers, subset);
    }
    mismatches(context, mismatched, actuals) {
        if (ofType_1.ofType.isArray(actuals)) {
            if (actuals.length === 0 && this.matchers.length === 0) {
                return new MatchResult_1.MatchResult(undefined, 1, 1);
            }
            const matcherPerActual = actuals.map(a => ({ matcher: undefined }));
            const matchedActual = actuals.map(a => false);
            const failingMatchers = [];
            this.matchers.forEach(matcher => this.tryMatch(context, matcher, actuals, matcherPerActual, matchedActual, failingMatchers));
            let compares = 0;
            let matches = 0;
            const results = matcherPerActual.map((matched, i) => {
                const actual = actuals[i];
                if (matched.matcher) {
                    const result = matched.matcher.mismatches(context.add("[" + i + "]"), mismatched, actual);
                    compares += result.compares;
                    matches += result.matchRate * result.compares;
                    if (result.passed()) {
                        return actual;
                    }
                    else {
                        return result.diff;
                    }
                }
                else {
                    if (this.subset)
                        return actual;
                    compares += 1;
                    return { [MatchResult_1.MatchResult.unexpected]: actuals[i] };
                }
            });
            compares += failingMatchers.length;
            failingMatchers.forEach(matcher => results.push({ [MatchResult_1.MatchResult.expected]: matcher.describe() }));
            return new MatchResult_1.MatchResult(results, compares, matches);
        }
        mismatched.push(Mismatched_1.Mismatched.makeExpectedMessage(context, actuals, (this.subset ? "sub" : "") + "array expected"));
        return MatchResult_1.MatchResult.wasExpected(actuals, this.describe(), 1, 0);
    }
    tryMatch(context, matcher, actuals, matcherPerActual, matchedActual, failingMatchers) {
        let bestActualIndex = -1;
        let bestMatchResult = undefined;
        for (let i = 0; i < actuals.length; i++) {
            if (!matchedActual[i]) {
                const actual = actuals[i];
                const result = matcher.trialMatches(actual);
                if (result.passed() || result.matchedObjectKey) {
                    matchedActual[i] = true;
                    matcherPerActual[i].matcher = matcher;
                    return;
                }
                if (!bestMatchResult || result.matchRate > bestMatchResult.matchRate) {
                    bestMatchResult = result;
                    bestActualIndex = i;
                }
            }
        }
        if (bestActualIndex >= 0) {
            matchedActual[bestActualIndex] = true;
            matcherPerActual[bestActualIndex].matcher = matcher;
        }
        else {
            failingMatchers.push(matcher);
        }
    }
    describe() {
        const unorderedArray = Array.from(this.matchers).map(e => e.describe());
        return this.subset ? { subset: unorderedArray } : unorderedArray;
    }
}
exports.UnorderedArrayMatcher = UnorderedArrayMatcher;
//# sourceMappingURL=UnorderedArrayMatcher.js.map