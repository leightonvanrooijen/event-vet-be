"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assertThat_1 = require("../assertThat");
const match_1 = require("../match");
const MatchResult_1 = require("../MatchResult");
const AllOfMatcher_1 = require("./AllOfMatcher");
const validateThat_1 = require("../validateThat");
const DiffMatcher_1 = require("./DiffMatcher");
describe("AllOfMatcher:", () => {
    describe("assertThat():", () => {
        it("Matches", () => {
            (0, assertThat_1.assertThat)({ a: 2 }).isAllOf([]);
            (0, assertThat_1.assertThat)({ a: 2 }).isAllOf([match_1.match.instanceOf(Object)]);
            (0, assertThat_1.assertThat)(new Date()).isAllOf([match_1.match.instanceOf(Object), match_1.match.instanceOf(Date)]);
        });
        it("Mismatches", () => {
            (0, assertThat_1.assertThat)(3)
                .failsWith(match_1.match.allOf([match_1.match.instanceOf(Date), 3]), { [MatchResult_1.MatchResult.was]: 3, [MatchResult_1.MatchResult.expected]: { instanceOf: "Date" } });
        });
        it("Mismatches: errors", () => {
            const mismatched = [];
            const matcher = AllOfMatcher_1.AllOfMatcher.make([match_1.match.instanceOf(Date), 3]);
            matcher.mismatches(new DiffMatcher_1.ContextOfValidationError(), mismatched, 4);
            (0, assertThat_1.assertThat)(mismatched).is([
                { actual: 4, expected: { instanceOf: "Date" } },
                { actual: 4, expected: 3 }
            ]);
        });
        it("Optimise with 1", () => {
            const whatever = match_1.match.ofType.array();
            (0, assertThat_1.assertThat)(match_1.match.allOf([whatever])).is(match_1.match.itIs(whatever));
        });
        it("Optimise with 1 left after removing match.any()s", () => {
            const whatever = match_1.match.ofType.array();
            (0, assertThat_1.assertThat)(match_1.match.allOf([match_1.match.any(), whatever, match_1.match.any()])).is(match_1.match.itIs(whatever));
        });
    });
    describe("validateThat():", () => {
        it("succeeds", () => {
            const expected = [match_1.match.ofType.number()];
            const validation = (0, validateThat_1.validateThat)(3).satisfies(match_1.match.allOf(expected));
            (0, assertThat_1.assertThat)(validation.passed()).is(true);
        });
        it("fails", () => {
            const expected = match_1.match.allOf([match_1.match.instanceOf(Date), match_1.match.ofType.number()]);
            const validation = (0, validateThat_1.validateThat)(3).satisfies(expected);
            (0, assertThat_1.assertThat)(validation.passed()).is(false);
            (0, assertThat_1.assertThat)(validation.errors).is([
                `{actual: 3, expected: {instanceOf: "Date"}}`
            ]);
        });
    });
});
//# sourceMappingURL=AllOfMatcher.micro.js.map