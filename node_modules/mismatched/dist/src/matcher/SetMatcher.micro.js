"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assertThat_1 = require("../assertThat");
const match_1 = require("../match");
const MatchResult_1 = require("../MatchResult");
const validateThat_1 = require("../validateThat");
describe("set:", () => {
    describe("set.match:", () => {
        describe("assertThat():", () => {
            it('matches when both empty', () => {
                (0, assertThat_1.assertThat)(new Set()).is(match_1.match.aSet.match(new Set()));
                (0, assertThat_1.assertThat)([]).is(match_1.match.aSet.match([]));
                (0, assertThat_1.assertThat)(new Set([])).is(match_1.match.aSet.match([]));
            });
            it('matches', () => {
                (0, assertThat_1.assertThat)(new Set([1, 2, 3])).is(match_1.match.aSet.match(new Set([1, 2, 3])));
                (0, assertThat_1.assertThat)([1, 2, 3]).is(match_1.match.aSet.match([2, 1, 3]));
                (0, assertThat_1.assertThat)(new Set([1, 2, 3])).is(match_1.match.aSet.match([3, 2, 1]));
                (0, assertThat_1.assertThat)([[1, 1], [2, 2], [3, 3]]).is(match_1.match.aSet.match([[1, 1], [2, 2], [3, 3]]));
            });
            it('matches right', () => {
                (0, assertThat_1.assertThat)(new Set([1, 2, 3])).is(match_1.match.aSet.match(new Set([1, 2, match_1.match.any()])));
                (0, assertThat_1.assertThat)([1, 2, 3]).is(match_1.match.aSet.match([2, 1, match_1.match.any()]));
                (0, assertThat_1.assertThat)([[1, 1], [2, 2], [3, 3]])
                    .is(match_1.match.aSet.match([[1, 1], [2, 2], match_1.match.ofType.array()]));
            });
            it('matches with nested has', () => {
                (0, assertThat_1.assertThat)([{ s: true, extra: 'junk' }, { s: undefined, extra: 'extra' }]).is(match_1.match.aSet.match([
                    match_1.match.obj.has({ s: true }),
                    match_1.match.obj.has({ s: undefined })
                ]));
            });
            it('does not match: too many', () => {
                const actual = new Set([1, 2, 3]);
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.aSet.match(new Set([1, 2])), [1, 2, { [MatchResult_1.MatchResult.unexpected]: 3 }]);
            });
            it('does not match: too few', () => {
                const actual = new Set([1, 2]);
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.aSet.match(new Set([1, 2, 3])), [1, 2, { [MatchResult_1.MatchResult.expected]: 3 }]);
            });
            it('does not match: values mismatch', () => {
                const actual = new Set([1, 2, 3]);
                const expected = new Set([1, 2, 4]);
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.aSet.match(expected), [1, 2, { [MatchResult_1.MatchResult.was]: 3, [MatchResult_1.MatchResult.expected]: 4 }
                ]);
            });
            it('matches literally nested', () => {
                const actual = new Set([1, 2, new Set([3, [5]])]);
                (0, assertThat_1.assertThat)(actual).is(new Set([1, 2, new Set([3, [5]])]));
            });
            it('does not match literally nested', () => {
                const actual = new Set([1, 2, new Set([3, [5]])]);
                const expected = new Set([1, 2, new Set([44, [5]])]);
                (0, assertThat_1.assertThat)(actual).failsWith(expected, [1, 2, [{ [MatchResult_1.MatchResult.was]: 3, [MatchResult_1.MatchResult.expected]: 44 }, [5]]]);
            });
            it('matches the best first', () => {
                const actual = new Set([{ a: 1, b: [0] }, { a: 11, b: [0] }]);
                const expected = new Set([{ a: 11, b: [1] }]);
                (0, assertThat_1.assertThat)(actual).failsWith(expected, [
                    { [MatchResult_1.MatchResult.unexpected]: { a: 1, b: [0] } },
                    { a: 11, b: [{ [MatchResult_1.MatchResult.unexpected]: 0 }, { [MatchResult_1.MatchResult.expected]: 1 }] }
                ]);
            });
            it('matches the best first deeply nested', () => {
                const actual = new Set([{ a: 1, b: { c: [1] } }, { a: 11, b: { c: [2] } }]);
                const expected = new Set([{ a: 11, b: { c: [3] } }]);
                (0, assertThat_1.assertThat)(actual).failsWith(expected, [
                    { [MatchResult_1.MatchResult.unexpected]: { a: 1, b: { c: [1] } } },
                    { a: 11, b: { c: [{ [MatchResult_1.MatchResult.unexpected]: 2 }, { [MatchResult_1.MatchResult.expected]: 3 }] } }
                ]);
            });
            it('matches with a key', () => {
                const actual = new Set([{ a: 1, b: 1 }, { a: 2, b: 2 }]);
                const expected = new Set([
                    { a: match_1.match.obj.key(1), b: 2 },
                    { a: match_1.match.obj.key(2), b: 0 }
                ]);
                (0, assertThat_1.assertThat)(actual).failsWith(expected, [
                    { a: 1, b: { [MatchResult_1.MatchResult.was]: 1, [MatchResult_1.MatchResult.expected]: 2 } },
                    { a: 2, b: { [MatchResult_1.MatchResult.was]: 2, [MatchResult_1.MatchResult.expected]: 0 } },
                ]);
            });
            it('matches with bind, but only once elements in the actual and expected sets have been matched', () => {
                const actual = new Set([{ a: 11, b: { c: [2] } }, { a: 1, b: { c: [1, 1] }, d: 1 }]);
                const bind = match_1.match.bind(match_1.match.ofType.number());
                const expected = new Set([{ a: bind, b: { c: [1, 1] }, d: bind }, { a: 11, b: { c: [2] } }]);
                (0, assertThat_1.assertThat)(actual).is(expected);
            });
        });
        describe("validateThat():", () => {
            const isNumber = match_1.match.ofType.number();
            const expected = new Set([isNumber, new Set([isNumber])]);
            it("succeeds", () => {
                const actual = new Set([1, new Set([4])]);
                const validation = (0, validateThat_1.validateThat)(actual).satisfies(expected);
                (0, assertThat_1.assertThat)(validation.errors).is([]);
                (0, assertThat_1.assertThat)(validation.passed()).is(true);
            });
            it("succeeds with general matcher", () => {
                const actual = new Set([1, 2]);
                const validation = (0, validateThat_1.validateThat)(actual).satisfies(new Set([1, match_1.match.any()]));
                (0, assertThat_1.assertThat)(validation.errors).is([]);
                (0, assertThat_1.assertThat)(validation.passed()).is(true);
            });
            it("fails as incorrect set", () => {
                const actual = new Set([1, new Set(["s"])]);
                const validation = (0, validateThat_1.validateThat)(actual).satisfies(expected);
                (0, assertThat_1.assertThat)(validation.passed()).is(false);
                (0, assertThat_1.assertThat)(validation.errors).is([
                    '{"actual[1][0]": "s", expected: "ofType.number"}'
                ]);
            });
            it("fails as not an array", () => {
                const validation = (0, validateThat_1.validateThat)(false).satisfies(expected);
                (0, assertThat_1.assertThat)(validation.passed()).is(false);
                (0, assertThat_1.assertThat)(validation.errors).is([
                    `{actual: false, expected: "set expected"}`
                ]);
            });
        });
    });
    describe("set.subset:", () => {
        describe("assertThat():", () => {
            it('subset', () => {
                const actual = new Set([1, 2, 3]);
                (0, assertThat_1.assertThat)(actual).is(match_1.match.aSet.subset(new Set([1, 2, 3])));
                (0, assertThat_1.assertThat)(actual).is(match_1.match.aSet.subset(new Set([1, 2])));
            });
            it('does not match: values differ', () => {
                const actual = new Set([1, 2, 3]);
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.aSet.subset(new Set([1, 4])), [1, { [MatchResult_1.MatchResult.was]: 2, [MatchResult_1.MatchResult.expected]: 4 }, 3]);
            });
            it('does not match: too many values expected', () => {
                const actual = new Set([1, 2, 3]);
                const expected = new Set([1, 2, 3, 4]);
                (0, assertThat_1.assertThat)(actual).failsWith(match_1.match.aSet.subset(expected), [1, 2, 3, { [MatchResult_1.MatchResult.expected]: 4 }]);
            });
        });
        describe("validateThat():", () => {
            const isNumber = match_1.match.ofType.number();
            const expected = new Set([isNumber, new Set([isNumber])]);
            it("succeeds", () => {
                const actual = new Set([1, new Set([4])]);
                const validation = (0, validateThat_1.validateThat)(actual).satisfies(match_1.match.aSet.subset(expected));
                (0, assertThat_1.assertThat)(validation.errors).is([]);
                (0, assertThat_1.assertThat)(validation.passed()).is(true);
            });
            it("fails as incorrect set", () => {
                const actual = new Set([1, new Set(["s"])]);
                const validation = (0, validateThat_1.validateThat)(actual).satisfies(match_1.match.aSet.subset(expected));
                (0, assertThat_1.assertThat)(validation.passed()).is(false);
                (0, assertThat_1.assertThat)(validation.errors).is([
                    '{"actual[1][0]": "s", expected: "ofType.number"}'
                ]);
            });
        });
    });
});
//# sourceMappingURL=SetMatcher.micro.js.map