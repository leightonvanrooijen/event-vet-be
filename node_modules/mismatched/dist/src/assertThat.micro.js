"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assertThat_1 = require("./assertThat");
const match_1 = require("./match");
const MatchResult_1 = require("./MatchResult");
const assert_1 = require("assert");
describe("assertThat():", () => {
    it("Ensure that mismatched basically works, without using itself", () => {
        if (!match_1.match.itIs(3).matches(3).passed())
            (0, assert_1.fail)("Mismatched did not match, but it should have");
        if (match_1.match.itIs(3).matches(4).passed())
            (0, assert_1.fail)("Mismatched matched but should not have");
        let exceptionThrown = false;
        try {
            (0, assertThat_1.assertThat)(3).is(4);
        }
        catch (e) {
            exceptionThrown = true;
        }
        if (!exceptionThrown)
            (0, assert_1.fail)("assertThat did not pick up error");
    });
    describe("is():", () => {
        it('matches', () => {
            const actual = 3.4;
            (0, assertThat_1.assertThat)(actual).is(actual);
        });
        it('mismatches', () => {
            (0, assertThat_1.assertThat)(3.4).failsWith(3.5, { [MatchResult_1.MatchResult.was]: 3.4, [MatchResult_1.MatchResult.expected]: 3.5 });
        });
    });
    describe("itIs():", () => {
        it('matches', () => {
            const actual = { f: 3.4 };
            (0, assertThat_1.assertThat)(actual).itIs(actual);
        });
        it('mismatches', () => {
            (0, assertThat_1.assertThat)(() => (0, assertThat_1.assertThat)({ f: 3.4 }).itIs({ f: 3.4 })).throws();
        });
    });
    describe("isNot():", () => {
        it("matches", () => {
            (0, assertThat_1.assertThat)(2).isNot(4);
        });
        it("mismatches", () => {
            (0, assertThat_1.assertThat)(2).failsWith(match_1.match.not(2), { [MatchResult_1.MatchResult.was]: 2, [MatchResult_1.MatchResult.expected]: { not: 2 } });
        });
    });
    describe("isAnyOf():", () => {
        it("Matches", () => {
            (0, assertThat_1.assertThat)(new Date()).isAnyOf([match_1.match.isEquals(3), match_1.match.instanceOf(Date)]);
            (0, assertThat_1.assertThat)(4).isAnyOf([match_1.match.isEquals(4), match_1.match.instanceOf(Date)]);
        });
        it("Mismatches", () => {
            (0, assertThat_1.assertThat)("ab")
                .failsWith(match_1.match.anyOf([match_1.match.instanceOf(Date)]), { [MatchResult_1.MatchResult.was]: "ab", [MatchResult_1.MatchResult.expected]: { instanceOf: "Date" } });
        });
    });
    describe("isAllOf():", () => {
        it("Matches", () => {
            (0, assertThat_1.assertThat)(3).isAllOf([match_1.match.isEquals(3), match_1.match.number.greater(2)]);
        });
        it("Mismatches", () => {
            (0, assertThat_1.assertThat)("ab")
                .failsWith(match_1.match.allOf([match_1.match.isEquals(3), match_1.match.number.greater(2)]), { [MatchResult_1.MatchResult.was]: "ab", [MatchResult_1.MatchResult.expected]: { allOf: [3, { "number.greater": 2 }] } });
        });
    });
    describe("throws()", () => {
        it("Matches by Error class", () => {
            (0, assertThat_1.assertThat)(() => {
                throw new Error("error");
            }).throws(match_1.match.instanceOf(Error));
        });
        it("Matches", () => {
            (0, assertThat_1.assertThat)(() => {
                throw new Error("error");
            }).throws(new Error("error"));
        });
        it("Matches with no expectation", () => {
            (0, assertThat_1.assertThat)(() => {
                throw new Error("error");
            }).throws();
        });
        it("Mismatches", () => {
            let passed = false;
            try {
                (0, assertThat_1.assertThat)(() => 3).throws(match_1.match.instanceOf(Error));
                passed = true;
            }
            catch (e) {
                (0, assertThat_1.assertThat)(e).is({ message: "Problem in throws()" });
            }
            (0, assertThat_1.assertThat)(passed).is(false);
        });
        it("Actual is not a function", () => {
            (0, assertThat_1.assertThat)(() => (0, assertThat_1.assertThat)(4).throws("error")).throws(match_1.match.instanceOf(Error));
        });
    });
    describe("throwsError()", () => {
        it("Matches all", () => {
            (0, assertThat_1.assertThat)(() => {
                throw new Error("error");
            }).throwsError(match_1.match.string.startsWith("e"));
            const matcher = match_1.match.string.startsWith("e");
        });
        it("Matches start", () => {
            (0, assertThat_1.assertThat)(() => {
                throw new Error("error");
            }).throwsError("error");
        });
    });
    describe("catches():", () => {
        it("Matches", () => {
            return (0, assertThat_1.assertThat)(Promise.reject(4)).catches(4);
        });
        it("Matches Error", () => {
            return (0, assertThat_1.assertThat)(Promise.reject(new Error('err'))).catches(new Error('err'));
        });
        it("Matches Error in an async function with await", () => __awaiter(void 0, void 0, void 0, function* () {
            return yield (0, assertThat_1.assertThat)(Promise.reject(new Error('err'))).catches(new Error('err'));
        }));
        it("Mismatches", () => {
            return (0, assertThat_1.assertThat)(Promise.resolve(4))
                .catches(4)
                .catch((e) => (0, assertThat_1.assertThat)(e).is("Problem in catches()"));
        });
        it("Actual is not a function", () => {
            const assertionFn = () => (0, assertThat_1.assertThat)(4).catches("error");
            return (0, assertThat_1.assertThat)(assertionFn).throws(match_1.match.instanceOf(Error));
        });
        it("Return from actual function is not a Promise", () => {
            const assertionFn = () => (0, assertThat_1.assertThat)(4).catches("error");
            return (0, assertThat_1.assertThat)(assertionFn).throws(match_1.match.instanceOf(Error));
        });
        it("Alternative", () => {
            return Promise
                .reject(4)
                .then(() => (0, assert_1.fail)("Unexpected"), e => (0, assertThat_1.assertThat)(e).is(4));
        });
    });
    it("catchesError()", () => {
        (0, assertThat_1.assertThat)(Promise.reject(new Error("error")))
            .catchesError("error");
        (0, assertThat_1.assertThat)(Promise.reject(new Error("error")))
            .catchesError(match_1.match.string.startsWith("err"));
    });
});
//# sourceMappingURL=assertThat.micro.js.map