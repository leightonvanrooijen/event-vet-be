"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayDiff = void 0;
const diff = require("fast-array-diff");
const DoubleMap_1 = require("./DoubleMap");
const prelude_ts_1 = require("prelude-ts");
const arrayDiff = (matchers, actuals) => {
    const doubleMap = new DoubleMap_1.DoubleMap(); // Assumes we don't share Matchers
    const compare = (value, matcher) => {
        const matchResult = doubleMap.get(value, matcher);
        if (matchResult) {
            return matchResult.passed() || matchResult.matchedObjectKey;
        }
        const matchResult2 = matcher.trialMatches(value);
        doubleMap.set(value, matcher, matchResult2);
        return matchResult2.passed() || matchResult2.matchedObjectKey;
    };
    const includeMatcher = (pair, matcher) => {
        if (pair.actual.isSome()) {
            const result = doubleMap.get(pair.actual.getOrThrow(), matcher);
            if (result) {
                pair.matcher = prelude_ts_1.Option.of(matcher);
            }
        }
    };
    const deltas = diff.getPatch(actuals, matchers, compare);
    const result = actuals.map((actual, index) => ({
        actual: new prelude_ts_1.Some(actual),
        actualIndex: index,
        matcher: prelude_ts_1.Option.none()
    }));
    let expectedOffset = 0;
    let actualOffset = 0;
    let removes = 0;
    let previousIndex = 0;
    deltas.forEach(delta => {
        const start = delta.oldPos + actualOffset;
        switch (delta.type) {
            case "add": // expected
                for (let i = previousIndex; i < start; i++) {
                    includeMatcher(result[i], matchers[expectedOffset]);
                    expectedOffset += 1;
                }
                const insert = delta.items.map(matcher => ({ actual: prelude_ts_1.Option.none(), matcher: prelude_ts_1.Option.of(matcher) }));
                result.splice(start, 0, ...insert);
                actualOffset += delta.items.length;
                previousIndex = delta.oldPos + actualOffset;
                expectedOffset += delta.items.length;
                break;
            case "remove": // unexpected
                for (let i = previousIndex; i < delta.oldPos + actualOffset; i++) {
                    includeMatcher(result[i], matchers[expectedOffset]);
                    expectedOffset += 1;
                }
                const end = start + delta.items.length;
                removes += delta.items.length;
                previousIndex = end;
                break;
        }
    });
    for (let i = previousIndex; i < result.length; i++) {
        includeMatcher(result[i], matchers[expectedOffset]);
        expectedOffset += 1;
    }
    for (let j = 0; j < result.length - 1; j++) {
        if (unexpected(result[j]) && expected(result[j + 1])) {
            const matchResult = result[j + 1].matcher.getOrThrow().matches(result[j].actual.getOrThrow());
            if (matchResult.matchRate > 0) {
                // Combine them
                result[j].matcher = result[j + 1].matcher;
                result.splice(j + 1, 1);
            }
        }
    }
    return result;
};
exports.arrayDiff = arrayDiff;
const unexpected = (possible) => possible.actual.isSome() && possible.matcher.isNone();
const expected = (possible) => possible.actual.isNone() && possible.matcher.isSome();
//# sourceMappingURL=arrayDiff.js.map