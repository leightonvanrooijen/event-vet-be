"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assertThat_1 = require("../assertThat");
const PrettyPrinter_1 = require("../prettyPrint/PrettyPrinter");
const decompileActual_1 = require("./decompileActual");
describe("decompile()", () => {
    it("is primitive, unmapped", () => {
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(null, {})).is(null);
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(undefined, {})).is(undefined);
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(1.2, {})).is(1.2);
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)("abc", {})).is("abc");
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(false, {})).is(false);
    });
    it("is primitive, mapped", () => {
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(null, { n: null })).is(identifier('n'));
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(undefined, { u: undefined })).is(undefined);
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(1.2, { n: 1.2 })).is(identifier('n'));
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)("abc", { s: "abc" })).is(identifier('s'));
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(false, { f: false })).is(identifier('f'));
    });
    it("is object and array unmapped", () => {
        const actual = { a: [1, [2]], b: { c: "d" } };
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(actual, {})).is(actual);
    });
    it("is object and array mapped", () => {
        let E;
        (function (E) {
            E["A"] = "A1";
            E["B"] = "B2";
            E["C"] = "C3";
        })(E || (E = {}));
        const two = 2;
        const a1 = 'A1';
        const a2 = [two];
        const aa = [1, a2];
        const dee = "d";
        const b = { c: dee };
        const productCode = '123456';
        const product = { productCode };
        const actual = { a: aa, b, ce: E.A, product, productCode };
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(actual, { all: actual }, [E]))
            .is(identifier("all"));
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(actual, { aa, b }))
            .is(Object.assign(Object.assign({}, actual), { a: identifier("aa"), b: identifier("b") }));
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(actual, { aa, b }, { E }))
            .is(Object.assign(Object.assign({}, actual), { a: identifier("aa"), b: identifier("b"), ce: identifier('E.A') }));
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(actual, { aa }))
            .is(Object.assign(Object.assign({}, actual), { a: identifier("aa") }));
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(actual, { aa }, { E }))
            .is(Object.assign(Object.assign({}, actual), { a: identifier("aa"), ce: identifier('E.A') }));
        (0, assertThat_1.assertThat)((0, decompileActual_1.decompile)(actual, { a2 })).is(Object.assign(Object.assign({}, actual), { a: [1, identifier("a2")] }));
        // match.decompiledActual(actual, {dee, a1, counterpartyCode, counterparty}, {E})
    });
});
const identifier = (s) => ({ [PrettyPrinter_1.PrettyPrinter.symbolForPseudoCall]: s });
//# sourceMappingURL=decompiledActual.micro.js.map