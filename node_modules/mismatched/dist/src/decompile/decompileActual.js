"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decompile = exports.decompiledActual = void 0;
const ofType_1 = require("../ofType");
const PrettyPrinter_1 = require("../prettyPrint/PrettyPrinter");
const decompiledActual = (actual, contributors, enums = {}) => PrettyPrinter_1.PrettyPrinter.logToConsole((0, exports.decompile)(actual, contributors, enums));
exports.decompiledActual = decompiledActual;
const decompile = (actual, contributors, enums = {}) => mapToName(actual, buildMap(contributors, enums));
exports.decompile = decompile;
const buildMap = (contributors, enums) => {
    const mapValueToContributorNames = new Map();
    Object.keys(contributors).forEach(key => {
        walk(key, contributors[key], mapValueToContributorNames);
    });
    // Only use enums where no contributor (sub)value matches or there are more than one
    Object.keys(enums).forEach(enumKey => {
        const enumeration = enums[enumKey];
        Object.keys(enumeration).forEach(key => {
            const enumValue = enumeration[key];
            const contributors = mapValueToContributorNames.get(enumValue);
            if (!contributors || contributors.length > 1) {
                mapValueToContributorNames.set(enumValue, [`${enumKey}.${key}`]);
            }
        });
    });
    return new Map(Array.from(mapValueToContributorNames).map(mapElement => {
        const [key, values] = mapElement;
        return [key, values.join(" || ")];
    }));
};
const walk = (name, contributor, mapValueToContributorName) => {
    const references = mapValueToContributorName.get(contributor);
    // Do not override one with a shorter name
    if (references) {
        const currentLength = references[0].split('.').length;
        const newLength = name.split('.').length;
        if (newLength === currentLength) {
            references.push(name);
        }
        else if (newLength < currentLength) {
            mapValueToContributorName.set(contributor, [name]);
        }
    }
    else {
        mapValueToContributorName.set(contributor, [name]);
    }
    if (ofType_1.ofType.isArray(contributor)) {
        for (let i = 0; i < contributor.length; i++) {
            walk(`${name}[${i}]`, contributor[i], mapValueToContributorName);
        }
    }
    else if (ofType_1.ofType.isObject(contributor)) {
        Object.keys(contributor).forEach(key => {
            walk(`${name}.${key}`, contributor[key], mapValueToContributorName);
        });
    }
};
const mapToName = (actual, mapValueToContributorName) => {
    if (actual === undefined) {
        return undefined;
    }
    const source = mapValueToContributorName.get(actual);
    if (source) {
        return { [PrettyPrinter_1.PrettyPrinter.symbolForPseudoCall]: source };
    }
    if (ofType_1.ofType.isArray(actual)) {
        const result = [];
        for (let i = 0; i < actual.length; i++) {
            result.push(mapToName(actual[i], mapValueToContributorName));
        }
        return result;
    }
    if (ofType_1.ofType.isObject(actual)) {
        const result = {};
        Object.keys(actual).forEach(key => {
            result[key] = mapToName(actual[key], mapValueToContributorName);
        });
        return result;
    }
    return actual;
};
//# sourceMappingURL=decompileActual.js.map