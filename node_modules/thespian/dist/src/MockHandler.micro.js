"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MockHandler_1 = require("./MockHandler");
const assertThat_1 = require("mismatched/dist/src/assertThat");
const match_1 = require("mismatched/dist/src/match");
const MockHandlerFixture_1 = require("./MockHandlerFixture");
const Thespian_1 = require("./Thespian");
const SuccessfulCall_1 = require("./SuccessfulCall");
const methodName = "method";
const fnName = "";
describe('MockHandler()', () => {
    it("Call on an unknown method", () => {
        const handler = new MockHandler_1.MockHandler("thespian", []);
        (0, assertThat_1.assertThat)(() => handler.get(undefined, methodName, undefined)(12)).throwsError(`{
  problem: "Unable to handle call or access property, as it has not been mocked", 
  mockCall: thespian.method()
}`);
    });
    describe('method:', () => {
        it("Call known method with a single MockedCall, with undefined result", () => {
            const fixture = new MockHandlerFixture_1.MockHandlerFixture();
            fixture.makeMock(methodName, [match_1.match.any()])
                .returns(a => a);
            const fn = fixture.getMock(methodName);
            (0, assertThat_1.assertThat)(fn(5)).is(5);
            (0, assertThat_1.assertThat)(fixture.successes()).is([{
                    call: (0, SuccessfulCall_1.createPseudoCall)("thespian.method", [5]),
                    returnValue: 5, expectedTimes: 1
                }]);
        });
        it("Call known method with a single MockedCall, with specified result", () => {
            const fixture = new MockHandlerFixture_1.MockHandlerFixture();
            fixture.makeMock(methodName, [1])
                .returns(() => 456);
            const fn = fixture.getMock(methodName);
            (0, assertThat_1.assertThat)(fn(1)).is(456);
            (0, assertThat_1.assertThat)(fixture.successes()).is([{
                    call: (0, SuccessfulCall_1.createPseudoCall)("thespian.method", [1]),
                    returnValue: 456, expectedTimes: 1
                }]);
        });
        it("Call known method with a single MockedCall, but doesn't match", () => {
            const fixture = new MockHandlerFixture_1.MockHandlerFixture();
            fixture.makeMock(methodName, [1])
                .returns(() => 456);
            const fn = fixture.getMock(methodName);
            (0, assertThat_1.assertThat)(() => fn(2)).throws(match_1.match.any());
            (0, assertThat_1.assertThat)(fixture.successes()).is([]);
        });
        it("Call known method with a 2 MockedCall2, with one matching", () => {
            const fixture = new MockHandlerFixture_1.MockHandlerFixture();
            fixture.makeMock(methodName, [1, 2])
                .returns(() => 456);
            fixture.makeMock(methodName, [2, 3])
                .returns(() => 789);
            const fn = fixture.getMock(methodName);
            (0, assertThat_1.assertThat)(fn(1, 2)).is(456);
            (0, assertThat_1.assertThat)(fn(2, 3)).is(789);
            (0, assertThat_1.assertThat)(fixture.successes()).is([
                { call: (0, SuccessfulCall_1.createPseudoCall)("thespian.method", [1, 2]), returnValue: 456, expectedTimes: 1 },
                { call: (0, SuccessfulCall_1.createPseudoCall)("thespian.method", [2, 3]), returnValue: 789, expectedTimes: 1 }
            ]);
        });
    });
    describe('function:', () => {
        it("Call known function with no match", () => {
            const fixture = new MockHandlerFixture_1.MockHandlerFixture();
            fixture.makeMock(fnName, [1])
                .returns(() => 5);
            const fn = fixture.getMock(fnName);
            (0, assertThat_1.assertThat)(() => fn("a")).throws(match_1.match.any());
            (0, assertThat_1.assertThat)(fixture.successes()).is([]);
        });
        it("Call known function with a match", () => {
            const fixture = new MockHandlerFixture_1.MockHandlerFixture();
            fixture.makeMock(fnName, [1])
                .returns(() => 456);
            const fn = fixture.getMock(fnName);
            (0, assertThat_1.assertThat)(fn(1)).is(456);
            (0, assertThat_1.assertThat)(fixture.successes()).is([
                {
                    call: (0, SuccessfulCall_1.createPseudoCall)("thespian", [1]),
                    returnValue: 456, expectedTimes: 1
                }
            ]);
        });
    });
    it("symbolForMockToString", () => {
        const fixture = new MockHandlerFixture_1.MockHandlerFixture();
        fixture.makeMock(methodName, [1])
            .returns(() => 5);
        const fn = fixture.getMock(Thespian_1.Thespian.symbolForMockToString);
        (0, assertThat_1.assertThat)(fn()).is("thespian");
    });
});
//# sourceMappingURL=MockHandler.micro.js.map