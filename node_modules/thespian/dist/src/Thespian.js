"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Thespian = void 0;
const Mocked_1 = require("./Mocked");
const mismatched_1 = require("mismatched");
const generateMocks_1 = require("./generate/generateMocks");
const generateBuilder_1 = require("./generate/generateBuilder");
const generateValidator_1 = require("./generate/generateValidator");
let mockCount = 1;
class Thespian {
    constructor() {
        this.mocks = []; // One for each Mocked object or function
        this.successfulCalls = [];
    }
    static generateMocks(fileName, elementaryInterfaces = [], elementaryClasses = {}, enums = {}) {
        const elementaryClassSet = new Set(Object.keys(elementaryClasses));
        elementaryInterfaces.forEach(ei => elementaryClassSet.add(ei));
        const enumMap = new Map();
        Object.keys(enums).forEach(key => enumMap.set(key, (Object.keys(enums[key]))[0]));
        console.log((0, generateMocks_1.generateMocks)(fileName, elementaryClassSet, enumMap));
    }
    static generateBuilder(fileName, elementaryInterfaces = [], elementaryClasses = {}, enums = {}) {
        const elementaryClassSet = new Set(Object.keys(elementaryClasses));
        elementaryInterfaces.forEach(ei => elementaryClassSet.add(ei));
        const enumMap = new Map();
        Object.keys(enums).forEach(key => enumMap.set(key, (Object.keys(enums[key]))[0]));
        console.log((0, generateBuilder_1.generateBuilder)(fileName, elementaryClassSet, enumMap));
    }
    static generateValidator(fileName, elementaryInterfaces = [], elementaryClasses = {}, enums = {}) {
        const elementaryClassSet = new Set(Object.keys(elementaryClasses));
        elementaryInterfaces.forEach(ei => elementaryClassSet.add(ei));
        const enumMap = new Map();
        Object.keys(enums).forEach(key => enumMap.set(key, (Object.keys(enums[key]))[0]));
        console.log((0, generateValidator_1.generateValidator)(fileName, elementaryClassSet, enumMap));
    }
    mock(name = "mock#" + mockCount++) {
        const mock = new Mocked_1.Mocked(name, this.successfulCalls);
        this.mocks.push(mock);
        return mock;
    }
    displayPassedCalls() {
        Thespian.printer.logToConsole(this.successfulCalls);
    }
    verify() {
        const errors = [];
        this.mocks.forEach(m => m.verify(errors));
        if (errors.length > 0) {
            throw new Error("Problem(s) with mock expectations not being met:\n" +
                Thespian.printer.render(errors));
        }
    }
    describeMocks() {
        Thespian.printer.logToConsole(this.mocks.map(m => m.describeMocks()));
    }
}
exports.Thespian = Thespian;
Thespian.symbolForMockToString = Symbol("symbolForMockToString");
Thespian.printer = mismatched_1.PrettyPrinter.make(80, 20, 10000, Thespian.symbolForMockToString);
//# sourceMappingURL=Thespian.js.map