"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMocks = void 0;
const ts = require("typescript");
const getCompiled_1 = require("../compiled/getCompiled");
const Compiled_1 = require("../compiled/Compiled");
const fillTemplate_1 = require("./fillTemplate");
const headerTemplate = `
import { Thespian, TMocked } from 'thespian'
import { assertThat, match } from 'mismatched'
`;
const template = `
describe('@{name}', () => {
  let thespian: Thespian @{lets}  
  
  beforeEach(() => {
    thespian = new Thespian() @{initialisers}
  })

  afterEach(() => thespian.verify())
})
`;
const generateMocks = (fileName, elementaryClassSet, enumMap) => {
    var cmd = ts.parseCommandLine([fileName]);
    let program = ts.createProgram(cmd.fileNames, cmd.options);
    const sourceFile = program.getSourceFile(fileName);
    const results = [];
    const classDetails = (0, getCompiled_1.getCompiled)(sourceFile, elementaryClassSet, enumMap);
    classDetails.forEach(classDetail => mockClassOrFunction(classDetail, results));
    if (results.length > 0) {
        return headerTemplate + results.join();
    }
    return '';
};
exports.generateMocks = generateMocks;
const mockClassOrFunction = (compiled, results) => {
    let someMocks = false;
    let lets = '';
    let initialisers = '';
    switch (compiled.type) {
        case Compiled_1.CompiledType.ClassType:
            const className = compiled.name;
            compiled.parameters.forEach(param => {
                if (!param.isPrimitive()) {
                    someMocks = true;
                    lets += param.displayLet();
                    initialisers += param.displayInitialiser();
                }
            });
            if (someMocks) {
                const params = compiled.parameters.map(p => p.displayMockOrValue()).join(", ");
                const variableName = lowerFirst(className);
                const classNameWithGenerics = compiled.genericParameters.length > 0 ?
                    `${className}<${compiled.genericParameters.map(g => g.displayType()).join(', ')}>` :
                    className;
                lets += `\n  let ${variableName}: ${classNameWithGenerics}`;
                initialisers += `\n    ${variableName} = new ${classNameWithGenerics}(${params})`;
                results.push((0, fillTemplate_1.fillTemplate)(template, { name: className, lets, initialisers }));
            }
            break;
        case Compiled_1.CompiledType.InterfaceType:
            break;
        case Compiled_1.CompiledType.FunctionType:
            compiled.parameters.forEach(param => {
                if (!param.isPrimitive()) {
                    someMocks = true;
                    lets += param.displayLet();
                    initialisers += param.displayInitialiser();
                }
            });
            if (someMocks) {
                results.push((0, fillTemplate_1.fillTemplate)(template, { name: compiled.name, lets, initialisers }));
            }
            break;
    }
};
const lowerFirst = (s) => s.length > 0 ? s.charAt(0).toLowerCase() + s.substring(1) : '';
//# sourceMappingURL=generateMocks.js.map