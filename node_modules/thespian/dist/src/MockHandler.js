"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockHandler = exports.minimumMatchRateForNearMiss = void 0;
const Thespian_1 = require("./Thespian");
const mismatched_1 = require("mismatched");
const ofType_1 = require("mismatched/dist/src/ofType");
exports.minimumMatchRateForNearMiss = 0.2;
class MockHandler {
    constructor(mockName, successfulCalls) {
        this.mockName = mockName;
        this.successfulCalls = successfulCalls;
        this.mapMethodToMockCalls = new Map();
        this.mapPropertyToFunctions = new Map();
    }
    addCall(mockCall) {
        const mockCalls = this.mapMethodToMockCalls.get(mockCall.methodName);
        if (!mockCalls) {
            this.mapMethodToMockCalls.set(mockCall.methodName, [mockCall]);
        }
        else {
            mockCalls.push(mockCall);
        }
    }
    addProperty(mockedProperty) {
        const mockCalls = this.mapPropertyToFunctions.get(mockedProperty.propertyName);
        if (!mockCalls) {
            this.mapPropertyToFunctions.set(mockedProperty.propertyName, [mockedProperty]);
        }
        else {
            mockCalls.push(mockedProperty);
        }
    }
    get(target, propKey, receiver) {
        const self = this;
        if (propKey === Thespian_1.Thespian.symbolForMockToString) {
            return () => self.mockName;
        }
        if (ofType_1.ofType.isSymbol(propKey) || propKey === "inspect" || propKey === "name") {
            return undefined;
        }
        const fullMockName = `${self.mockName}.${propKey.toString()}`;
        function returnedFn() {
            return self.runRightCall(propKey, fullMockName, Array.from(arguments));
        }
        function mismatchedFn() {
            self.failedToMatch("Unable to handle call or access property, as it has not been mocked", fullMockName, Array.from(arguments), []);
        }
        const propertyAccesses = this.mapPropertyToFunctions.get(propKey);
        if (propertyAccesses) {
            return this.accessProperty(propertyAccesses, fullMockName);
        }
        if (this.mapMethodToMockCalls.has(propKey)) {
            return returnedFn;
        }
        // Unfortunately, we can't return the function to get the real args because it may be a property access:
        return mismatchedFn();
    }
    // Called by apply() and call().
    apply(target, thisArg, actualArguments) {
        return this.runRightCall(MockHandler.applyKey, this.mockName, actualArguments);
    }
    error(msg) {
        throw new Error(Thespian_1.Thespian.printer.render(msg));
    }
    has(target, propKey) {
        const mockCalls = this.mapMethodToMockCalls.get(propKey);
        return !!mockCalls;
    }
    set(target, propKey, value) {
        throw new Error(`Not yet implemented: Unable to set ${propKey} to ${value}`);
    }
    deleteProperty(target, propKey) {
        throw new Error(`Not yet implemented: Unable to delete property ${propKey}`);
    }
    getOwnPropertyDescriptor(target, prop) {
        try {
            return { configurable: true, enumerable: true, value: this.get(target, prop, undefined) };
        }
        catch (e) {
            return undefined;
        }
    }
    verify(errors) {
        this.mapMethodToMockCalls.forEach(mockCalls => mockCalls.filter(m => !m.hasPassed()).forEach(m => errors.push(m.describe())));
        this.mapPropertyToFunctions.forEach(mockCalls => mockCalls.filter(m => !m.hasPassed()).forEach(m => errors.push(m.describe())));
    }
    describeMocks() {
        const result = [];
        this.mapMethodToMockCalls.forEach(mockCalls => mockCalls.filter(m => m.hasRun()).forEach(m => result.push(m.describe())));
        this.mapPropertyToFunctions.forEach(mockAccesses => mockAccesses.filter(m => m.hasRun()).forEach(m => result.push(m.describe())));
        return result;
    }
    accessProperty(propertyAccesses, mockName) {
        const nearMisses = [];
        for (let access of propertyAccesses) {
            const result = access.access();
            if (result.failed) {
                nearMisses.push(result.failed);
            }
            else {
                return result.result;
            }
        }
        const msg = {
            problem: "Unable to access",
            property: { [mismatched_1.PrettyPrinter.symbolForPseudoCall]: mockName }
        };
        if (nearMisses.length > 0) {
            msg.tooOften = nearMisses;
        }
        this.error(msg);
    }
    runRightCall(key, mockName, actualArguments) {
        const nearMisses = [];
        const mockCalls = this.mapMethodToMockCalls.get(key);
        if (mockCalls) {
            for (let call of mockCalls) {
                const did = call.matchToRunResult(actualArguments);
                if (!did.failed) {
                    return did.result;
                }
                if (did.failed.matchRate >= exports.minimumMatchRateForNearMiss) {
                    nearMisses.push(did.failed);
                }
            }
        }
        const hasTooManyTimes = nearMisses.some(miss => miss.actualTimes > miss.expectedTimes);
        if (nearMisses.length == 1 && hasTooManyTimes) {
            this.failedToMatch("Unable to handle call, as it's called too many times", mockName, actualArguments, []);
        }
        else {
            const problem = "Unable to handle call, as none match";
            this.failedToMatch(hasTooManyTimes ? problem + " or it's called too many times" : problem, mockName, actualArguments, nearMisses);
        }
    }
    failedToMatch(problem, mockName, actualArguments, nearMisses) {
        const msg = {
            problem,
            mockCall: {
                [mismatched_1.PrettyPrinter.symbolForPseudoCall]: mockName,
                args: actualArguments
            }
        };
        if (nearMisses.length > 0) {
            msg.nearMisses = nearMisses.map(s => s.describe());
        }
        if (this.successfulCalls.length > 0) {
            msg.previousSuccessfulCalls = this.successfulCalls.map(s => s.describe());
        }
        this.error(msg);
    }
}
exports.MockHandler = MockHandler;
MockHandler.applyKey = "";
//# sourceMappingURL=MockHandler.js.map