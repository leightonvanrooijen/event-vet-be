"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mocked = void 0;
const MockedCall_1 = require("./MockedCall");
const MockHandler_1 = require("./MockHandler");
const ofType_1 = require("mismatched/dist/src/ofType");
const DefinedSetUp_1 = require("./DefinedSetUp");
const MockedProperty_1 = require("./MockedProperty");
const matchMaker_1 = require("mismatched/dist/src/matchMaker/matchMaker");
let expectedArgs;
class Mocked {
    constructor(mockName, successfulCalls, handler = new MockHandler_1.MockHandler(mockName, successfulCalls)) {
        this.mockName = mockName;
        this.successfulCalls = successfulCalls;
        this.handler = handler;
        // Seems that we need the proxy target to be a function in order to allow for mocked functions!
        this.object = new Proxy(() => 3, this.handler);
    }
    setup(f) {
        if (!ofType_1.ofType.isFunction(f)) {
            throw new Error("An arrow/function must be provided in setup()");
        }
        const setUpDetails = DefinedSetUp_1.DefinedSetUp.details(f);
        switch (setUpDetails._type) {
            case DefinedSetUp_1.SetUpType.Property:
                return this.setUpPropertyAccess(f, setUpDetails);
            case DefinedSetUp_1.SetUpType.Method:
                return this.setUpMethodCall(f, setUpDetails);
            case DefinedSetUp_1.SetUpType.Function:
                return this.setUpFunctionCall(f, this.mockName);
        }
    }
    setUpPropertyAccess(f, setUpDetails) {
        const fieldName = setUpDetails.name;
        const fullName = this.mockName + "." + fieldName;
        const mockedProperty = new MockedProperty_1.MockedProperty(fullName, fieldName, this.successfulCalls);
        this.handler.addProperty(mockedProperty);
        return mockedProperty;
    }
    setUpMethodCall(f, setUpDetails) {
        const fieldName = setUpDetails.name;
        const fullName = this.mockName + "." + fieldName;
        const t = {
            [fieldName]: spyToGrabArguments
        };
        f(t);
        return this.addMockedCall(fullName, fieldName);
    }
    setUpFunctionCall(f, fullName) {
        f(spyToGrabArguments);
        const fieldName = MockHandler_1.MockHandler.applyKey;
        return this.addMockedCall(fullName, fieldName);
    }
    addMockedCall(fullName, fieldName) {
        const mockCall = new MockedCall_1.MockedCall(fullName, fieldName, expectedArgs.map(matchMaker_1.matchMaker), this.successfulCalls);
        this.handler.addCall(mockCall);
        return mockCall;
    }
    verify(errors) {
        this.handler.verify(errors);
    }
    describeMocks() {
        return this.handler.describeMocks();
    }
}
exports.Mocked = Mocked;
function spyToGrabArguments() {
    expectedArgs = Array.from(arguments);
}
//# sourceMappingURL=Mocked.js.map