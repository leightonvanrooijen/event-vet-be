"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockedCall = void 0;
const mismatched_1 = require("mismatched");
const Thespian_1 = require("./Thespian");
const SuccessfulCall_1 = require("./SuccessfulCall");
const UnsuccessfulCall_1 = require("./UnsuccessfulCall");
const matchMaker_1 = require("mismatched/dist/src/matchMaker/matchMaker");
const MockHandler_1 = require("./MockHandler");
// Attached to a Handler - one for each possible call:
class MockedCall {
    constructor(fullName, methodName, expectedArguments, successfulCalls, expectedArgs = mismatched_1.match.array.match(expectedArguments)) {
        this.fullName = fullName;
        this.methodName = methodName;
        this.successfulCalls = successfulCalls;
        this.expectedArgs = expectedArgs;
        this.expectedTimesInProgress = mismatched_1.match.isEquals(1);
        this.expectedTimes = mismatched_1.match.isEquals(1);
        this.actualTimes = 0;
        this.returnFn = () => undefined;
    }
    returns(fn) {
        this.returnFn = fn;
        return this;
    }
    returnsVoid() {
        return this;
    }
    times(count) {
        this.expectedTimes = (0, matchMaker_1.matchMaker)(count);
        this.expectedTimesInProgress = mismatched_1.match.number.lessEqual(count);
        return this;
    }
    timesAtLeast(count) {
        this.expectedTimes = mismatched_1.match.number.greaterEqual(count);
        this.expectedTimesInProgress = mismatched_1.match.number.greaterEqual(1);
        return this;
    }
    timesAtMost(count) {
        this.expectedTimes = mismatched_1.match.number.lessEqual(count);
        this.expectedTimesInProgress = mismatched_1.match.number.lessEqual(count);
        return this;
    }
    matchToRunResult(actualArgs) {
        const matchResult = this.expectedArgs.matches(actualArgs);
        const timesIncorrect = !this.expectedTimesInProgress.matches(this.actualTimes + 1).passed();
        const times = (timesIncorrect) ? this.actualTimes + 1 : this.actualTimes;
        if (!matchResult.passed()) {
            return this.makeNearMiss(matchResult, times);
        }
        if (timesIncorrect) {
            const failed = UnsuccessfulCall_1.UnsuccessfulCall.make(this.fullName, MockHandler_1.minimumMatchRateForNearMiss, actualArgs, this.expectedTimes.describe(), this.actualTimes + 1);
            return { failed };
        }
        try {
            const result = this.returnFn.apply(undefined, actualArgs);
            this.actualTimes += 1;
            this.successfulCalls.push(SuccessfulCall_1.SuccessfulCall.ofCall(this.fullName, actualArgs, result, this.expectedTimes.describe()));
            return { result };
        }
        catch (e) {
            Thespian_1.Thespian.printer.logToConsole({
                mockedReturn: this.fullName + '.' + this.methodName,
                failed: e.message || e,
            });
            throw e;
        }
    }
    makeNearMiss(matchResult, actualTimes) {
        return {
            failed: UnsuccessfulCall_1.UnsuccessfulCall.makeNearMiss(this.fullName, matchResult, this.expectedTimes.describe(), actualTimes)
        };
    }
    hasRun() {
        return this.actualTimes > 0;
    }
    hasPassed() {
        return this.expectedTimes.matches(this.actualTimes).passed();
    }
    describe() {
        return UnsuccessfulCall_1.UnsuccessfulCall.make(this.fullName, 0, this.expectedArgs.describe(), this.expectedTimes.describe(), this.actualTimes).describe();
    }
}
exports.MockedCall = MockedCall;
//# sourceMappingURL=MockedCall.js.map