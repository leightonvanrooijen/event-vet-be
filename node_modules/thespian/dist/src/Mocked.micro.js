"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mocked_1 = require("./Mocked");
const mismatched_1 = require("mismatched");
const MockFixture_1 = require("./MockFixture");
describe("Mocked:", () => {
    describe("setUp():", () => {
        it("Expects a lambda", () => {
            const fixture = new MockFixture_1.MockFixture();
            (0, mismatched_1.assertThat)(() => fixture.mockUnderTest.setup(4))
                .throwsError("An arrow/function must be provided in setup()");
        });
        it("Is a method", () => {
            const fixture = new MockFixture_1.MockFixture();
            const { mockUnderTest, mockHandler } = fixture;
            const expected = {
                fullName: "mockName.f", methodName: "f", successfulCalls: [],
                expectedTimesInProgress: { expected: 1, specificity: mismatched_1.match.any() },
                expectedTimes: { expected: 1, specificity: mismatched_1.match.any() },
                actualTimes: 0,
                expectedArgs: { elementMatchers: [], specificity: mismatched_1.match.any() },
                returnFn: mismatched_1.match.any()
            };
            mockHandler
                .setup(m => m.addCall(expected))
                .returnsVoid();
            (0, mismatched_1.assertThat)(mockUnderTest.setup(j => j.f())).is(expected);
        });
        it("Is a function", () => {
            const fixture = new MockFixture_1.MockFixture();
            const { mockHandler } = fixture;
            const mockUnderTest = new Mocked_1.Mocked("mockFnName", [], mockHandler.object);
            const expected = {
                fullName: "mockFnName", methodName: "", successfulCalls: [],
                expectedTimesInProgress: { expected: 1, specificity: mismatched_1.match.any() },
                expectedTimes: { expected: 1, specificity: mismatched_1.match.any() },
                actualTimes: 0,
                expectedArgs: { elementMatchers: [], specificity: mismatched_1.match.any() },
                returnFn: mismatched_1.match.any()
            };
            mockHandler
                .setup(m => m.addCall(expected))
                .returnsVoid();
            (0, mismatched_1.assertThat)(mockUnderTest.setup(f => f())).is(expected);
        });
        it("Is a property", () => {
            const fixture = new MockFixture_1.MockFixture();
            const { mockUnderTest, mockHandler } = fixture;
            const expected = {
                fullName: "mockName.f", methodName: "f", successfulCalls: [],
                expectedTimesInProgress: { expected: 1, specificity: mismatched_1.match.any() },
                expectedTimes: { expected: 1, specificity: mismatched_1.match.any() },
                actualTimes: 0, expectedArgs: { elementMatchers: [], specificity: mismatched_1.match.any() },
                returnFn: mismatched_1.match.any()
            };
            mockHandler
                .setup(m => m.addCall(expected))
                .returnsVoid();
            (0, mismatched_1.assertThat)(mockUnderTest.setup(j => j.f())).is(expected);
        });
    });
    it("verify()", () => {
        const fixture = new MockFixture_1.MockFixture();
        const { mockUnderTest, mockHandler } = fixture;
        mockHandler
            .setup(m => m.verify([0]))
            .returnsVoid();
        mockUnderTest.verify([0]);
        fixture.verify();
    });
    it("describeMocks()", () => {
        const fixture = new MockFixture_1.MockFixture();
        const { mockUnderTest, mockHandler } = fixture;
        mockHandler
            .setup(m => m.describeMocks())
            .returns(() => ["bla bla"]);
        (0, mismatched_1.assertThat)(mockUnderTest.describeMocks()).is(["bla bla"]);
        fixture.verify();
    });
});
//# sourceMappingURL=Mocked.micro.js.map