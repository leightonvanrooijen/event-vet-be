"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getName = exports.getCompiled = void 0;
const ts = require("typescript");
const typescript_1 = require("typescript");
const getCompiledType_1 = require("./getCompiledType");
const TType_1 = require("./TType");
const Compiled_1 = require("./Compiled");
const getCompiled = (source, elementaryClassSet, enumMap) => {
    const decompiledArray = [];
    ts.forEachChild(source, (node) => {
        if (ts.isClassDeclaration(node) && isExported(node)) {
            getCompiledClass(node, decompiledArray, elementaryClassSet, enumMap);
        }
        else if (ts.isInterfaceDeclaration(node)) {
            const anInterface = getCompiledInterface(node, elementaryClassSet, enumMap);
            decompiledArray.push(anInterface);
        }
        else if (ts.isVariableStatement(node) && isExported(node)) {
            getCompiledFunction(node, decompiledArray, elementaryClassSet, enumMap);
        }
    });
    return decompiledArray;
};
exports.getCompiled = getCompiled;
const getCompiledClass = (node, decompiledArray, elementaryClassSet, enumMap) => {
    const name = (0, exports.getName)(node.name);
    const genericParameters = (0, getCompiledType_1.mapGenericParameters)(node.typeParameters);
    node.members.forEach(member => {
        if (ts.isConstructorDeclaration(member)) {
            decompiledArray.push({
                type: Compiled_1.CompiledType.ClassType, name,
                genericParameters,
                parameters: getParameters(member.parameters, elementaryClassSet, enumMap),
                fields: [],
                methods: []
            });
        }
    });
};
const getCompiledInterface = (node, elementaryClassSet, enumMap) => {
    const name = (0, exports.getName)(node.name);
    const genericParameters = (0, getCompiledType_1.mapGenericParameters)(node.typeParameters);
    const methods = [];
    const fields = [];
    node.members.forEach(member => {
        if (member.kind === typescript_1.SyntaxKind.MethodSignature) {
            methods.push({
                name: (0, exports.getName)(member.name),
                genericParameters: (0, getCompiledType_1.mapGenericParameters)(member.typeParameters),
                parameters: getParameters(member.parameters, elementaryClassSet, enumMap),
                resultType: (0, getCompiledType_1.getCompiledType)(member.type, elementaryClassSet, enumMap)
            });
        }
        else if (member.kind === typescript_1.SyntaxKind.PropertySignature) {
            fields.push({
                name: (0, exports.getName)(member.name),
                resultType: (0, getCompiledType_1.getCompiledType)(member.type, elementaryClassSet, enumMap)
            });
        }
    });
    return { type: Compiled_1.CompiledType.InterfaceType, name, genericParameters, fields, methods };
};
const getCompiledFunction = (node, decompiledArray, elementaryClassSet, enumMap) => {
    const variableDeclarations = node.declarationList.declarations;
    if (Array.isArray(variableDeclarations) && variableDeclarations.length > 0) {
        const initializer = variableDeclarations[0].initializer;
        if (ts.isArrowFunction(initializer)) {
            const name = variableDeclarations[0].name.escapedText.toString();
            decompiledArray.push({
                type: Compiled_1.CompiledType.FunctionType, name, genericParameters: [],
                parameters: getParameters(initializer.parameters, elementaryClassSet, enumMap),
                resultType: new TType_1.TUnknown(999)
            });
        }
    }
};
const isExported = (node) => (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0;
const getName = (name) => { var _a; return ((_a = name === null || name === void 0 ? void 0 : name.escapedText) === null || _a === void 0 ? void 0 : _a.toString()) || 'unknown'; };
exports.getName = getName;
const getParameters = (parameters, elementaryClassSet, enumMap) => Array.from(parameters.map(p => new TType_1.TParam(p.name.escapedText, getParameterType(p, elementaryClassSet, enumMap))));
const getParameterType = (param, elementaryClassSet, enumMap) => {
    if (!param.type) {
        return new TType_1.TUnknown(0);
    }
    return (0, getCompiledType_1.getCompiledType)(param.type, elementaryClassSet, enumMap);
};
//# sourceMappingURL=getCompiled.js.map