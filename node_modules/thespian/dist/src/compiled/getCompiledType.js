"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapGenericParameters = exports.mapGenericArguments = exports.getCompiledType = void 0;
const typescript_1 = require("typescript");
const ofType_1 = require("mismatched/dist/src/ofType");
const TType_1 = require("./TType");
const getCompiled_1 = require("./getCompiled");
const getCompiledType = (type, elementaryClassSet, enumMap) => {
    const typeAny = type;
    switch (type.kind) {
        case typescript_1.SyntaxKind.StringKeyword:
            return new TType_1.TString();
        case typescript_1.SyntaxKind.NumberKeyword:
            return new TType_1.TNumber();
        case typescript_1.SyntaxKind.BooleanKeyword:
            return new TType_1.TBoolean();
        case typescript_1.SyntaxKind.SymbolKeyword:
            return new TType_1.TBuiltInClass('Symbol');
        case typescript_1.SyntaxKind.ObjectKeyword:
            return new TType_1.TClass('object');
        case typescript_1.SyntaxKind.AnyKeyword:
            return new TType_1.TClass('any');
        case typescript_1.SyntaxKind.TypeReference:
            return handleTypeReference(typeAny, elementaryClassSet, enumMap);
        case typescript_1.SyntaxKind.FunctionType:
            return new TType_1.TArrow(mapParameters(typeAny.parameters, elementaryClassSet, enumMap), (0, exports.getCompiledType)(typeAny.type, elementaryClassSet, enumMap));
        case typescript_1.SyntaxKind.UnionType:
            return new TType_1.TUnion(mapElements(typeAny.types, elementaryClassSet, enumMap));
        case typescript_1.SyntaxKind.IntersectionType:
            return new TType_1.TIntersection(mapElements(typeAny.types, elementaryClassSet, enumMap));
        case typescript_1.SyntaxKind.ArrayType:
            return new TType_1.TArray((0, exports.getCompiledType)(typeAny.elementType, elementaryClassSet, enumMap));
        case typescript_1.SyntaxKind.TupleType:
            return new TType_1.TTuple(mapElements(typeAny.elements, elementaryClassSet, enumMap));
        case typescript_1.SyntaxKind.VoidKeyword:
            return new TType_1.TVoid();
        default:
            return new TType_1.TUnknown(type.kind);
    }
};
exports.getCompiledType = getCompiledType;
const builtInClassSet = new Set([
    'Array', 'ArrayBuffer', 'AsynchFunction', 'Atomics',
    'BigInt', 'BigInt64Array', 'BigUint64Array', 'Boolean',
    'DataView', 'Date', 'Error', 'EvalError',
    'FinalizationRegistry', 'Float32Array', 'Float64Array', 'Function', 'Generator', 'GeneratorFunction',
    'InternalError', 'Intl', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object',
    'Promise', 'Proxy', 'RangeError', 'ReferenceError', 'Reflect', 'RegExp',
    'Set', 'SharedArrayBuffer', 'String', 'Symbol', 'TypedArray', 'TypeError',
    'UInt16Array', 'UInt32Array', 'UInt8Array', 'UInt8ClampedArray', 'UriError',
    'WeakMap', 'WeakSet', 'WebAssembly'
]);
const handleTypeReference = (type, elementaryClassSet, enumMap) => {
    const name = (0, getCompiled_1.getName)(type.typeName);
    if (builtInClassSet.has(name) || elementaryClassSet.has(name))
        return new TType_1.TBuiltInClass(name);
    const enumValue = enumMap.get(name);
    if (enumValue)
        return new TType_1.TEnum(name, enumValue);
    return new TType_1.TClass(name, (0, exports.mapGenericArguments)(type.typeArguments, elementaryClassSet, enumMap));
};
const mapElements = (elements, elementaryClassSet, enumMap) => elements.filter(e => ofType_1.ofType.isObject(e)).map(e => (0, exports.getCompiledType)(e, elementaryClassSet, enumMap));
const mapParameters = (parameters, elementaryClassSet, enumMap) => parameters.map(p => new TType_1.TParam(p.name.escapedText, (0, exports.getCompiledType)(p.type, elementaryClassSet, enumMap)));
const mapGenericArguments = (typeArguments, elementaryClassSet, enumMap) => mapElements(typeArguments || [], elementaryClassSet, enumMap).map(t => new TType_1.TGenericArgument(t));
exports.mapGenericArguments = mapGenericArguments;
const mapGenericParameters = (typeParameters) => (typeParameters || []).filter(e => ofType_1.ofType.isObject(e)).map(t => new TType_1.TGenericParameter((0, getCompiled_1.getName)(t.name)));
exports.mapGenericParameters = mapGenericParameters;
//# sourceMappingURL=getCompiledType.js.map